---
title: "Exercice Purrr"
output: formation::exo_rmd
params:
  hide:
    value: TRUE
  warning:
    value: FALSE
  message:
    value: FALSE
  results:
    value: 'hide'
  path: 
    value: "image/"
---

# Load necessary packages

```{r}
library(dplyr)
library(purrr)
library(attempt)
library(glue)
library(readr)
library(stringr)
library(tidyr)
```

# Retrieve data

The data are retrieved from the https://data.nantesmetropole.fr/ website.
We are looking to recover all data from 2010 to 2017. The data for each year are stored in different csv files. They are accessible with the following url in which it is only necessary to change the `YEAR`:

> https://data.nantesmetropole.fr/explore/dataset/244400404_compte-administratif-ca-YEAR-nantes/download/?format=csv&timezone=Europe/Berlin&use_labels_for_header=true

We will create a vector that will contain the different versions of "Administrative Account (CA) *YEAR* of the city of Nantes" (from 2010 to 2017): 
<https://data.nantesmetropole.fr/explore/?disjunctive.diffuseur&disjunctive.theme&disjunctive.features&disjunctive.publisher&disjunctive.gestionnaire&disjunctive.keyword&disjunctive.license&sort=explore.popularity_score&q=compte+administratif>

## URL writing function

- Create a `create_url` function that takes a year as input and returns the corresponding URL 
    + Put a test on it to return an error if the year is not between 2010 and 2017. *Look at the package {attempt}.*

```{r}
create_url <- function(year){
  attempt::stop_if_not(year, ~ between(.x, 2009, 2018), 
                       "Year must be between 2010 and 2017")
  glue::glue("https://data.nantesmetropole.fr/explore/dataset/244400404_compte-administratif-ca-{year}-nantes/download/?format=csv&timezone=Europe/Berlin&use_labels_for_header=true")
}
create_url(2010)
```

## Create all URL

- Using a `map` returning a character vector, create all urls between 2010 and 2017:

```{r}
years <- 2010:2017 # Needed for naming list then
a_dl <- map_chr(years, create_url)
```

## Create a version of `read_**` that will certainly succeed

- Create a `p_csv` function that allows you to read the downloaded file with the correct format
    + This function must not return an error if the url does not exist or if the `read_*` function is not adapted

```{r}
p_csv <- possibly(read_csv2, NULL) 
```

## Create a list containing all downloaded files

- Use the previous function `p_csv`
> The result should be a list of tibble

```{r}
all_df <- a_dl %>%
  map(p_csv)
```

## Name the list

The list we just obtained has no names. 

- Use the `set_names` function of {purrr} to name the items in the list with years (see `?set_names` if necessary)

```{r}
all_df <- all_df %>%
  set_names(years)
```

## Remove unsuccessful elements

We used a "safe" function created by {purrr}. Check that all downloads have been successful with the `map` returning logical values. 

- All objects must be tibbles

```{r}
map_lgl(all_df, is.tbl) %>%
  all()
```

Otherwise, remove failed items (see ?compact)

```{r}
all_df <- all_df %>%
  compact()
```

## Create a new list that gives the names of the columns of all tibbles

> The result is a list of vectors containing the names of the tibble columns

```{r}
all_df %>%
  map(names)
```

## Check that all tables have an column named "Montant"

Think about using the `map` returning logical

```{r}
map_lgl(all_df, ~ "Montant" %in% names(.x)) %>% all()
```

# Clean data

Each of our tables has a column names "Montant", which contains an amount, with the acronym `€` added at the end.

- Create a `clean_montant` function that takes a table as an input, cleans the "Montant" column by removing the `€`, and transforms it into a numerical variable.

```{r}
clean_montant <- function(df){
  df %>%
    mutate(Montant = str_remove_all(Montant, "€"), 
           Montant = as.numeric(Montant))
}
```

## Use this function on the entire list

```{r}
all_df <- map(all_df, clean_montant)
```

## Check that the operation has worked properly

- Create a function that takes a dataframe as input and outputs the class from the "Montant" column
- Run it on the list

```{r}
map_lgl(all_df, ~ class(.x$Montant) == "numeric") %>% all()
```

## Create a function to separate expenses from revenues

- The `filter_dep` function takes an input dataframe as well as the letter `D` or `R` as parameter.
- It filters the data set on the column `Dépenses/Recettes` according to the letter chosen as parameter

```{r}
filter_dep <- function(df, type){
  df %>%
    filter(`Dépenses/Recettes` == type)
}
```

## Create lists `dep` and `rec`

- Create two lists
    + One for "dépenses"
    + One for "recettes"

```{r}
dep <- map(all_df, ~ filter_dep(.x, "D"))
rec <- map(all_df, ~ filter_dep(.x, "R"))
```

## How many rows of each table of these two lists?

```{r}
map_dbl(dep, nrow)
map_dbl(rec, nrow)
```

## Extract column "Montant" of each table of list for "dépense"

- Store in an object named `montants`

```{r}
montants <- map(dep, "Montant") %>%
  map(as.numeric)
```
 
## Create new functions max, min, mean and var that removes `NA` values

- Name functions `*_no_na` (*e.g.* `max_no_na`)

```{r}
max_no_na <- partial(max, na.rm = TRUE)
min_no_na <- partial(min, na.rm = TRUE)
mean_no_na <- partial(mean, na.rm = TRUE)
var_no_na <- partial(var, na.rm = TRUE)
```

## Create a function to execute these four functions

- The `my_resume` function takes an input vector
- It will return a four-column tibble
    + Each performs one of the four functions

```{r}
my_resume <- function(x){
  tibble(
    max = max_no_na(x), 
    min = min_no_na(x), 
    mean = mean_no_na(x), 
    var = var_no_na(x)
  )
}
```

## Create a summary table of all years

- Perform the last function on the "dépenses" list
> The result must be in the form of a single table

```{r}
map_dfr(montants, my_resume, .id = "année")
```

# Go further using nested tibbles

## Create a tibble with a single column containing years of interest

```{r}
year_tbl <- tibble(year = years)
```

## Add a column containing all downloaded datasets

- Create a new column containing the url of the files using the column of years
- Create another new column that will be a list of nested tibbles by downloading from the URL column

```{r}
all_data <- year_tbl %>% 
  mutate(url = map_chr(year, create_url)) %>% 
  mutate(tbl = map(url, p_csv))
```

## Create the expense summary column

- Create the column of expenses only, from "Montant" column
- Calculate summaries (min, max, mean, var) on these data
- Unnest the "summary" column using `unnest`.

```{r}
all_data %>% 
  mutate(montant_dep = map(all_df, ~ filter_dep(.x, "D")) %>% 
           map("Montant")) %>% 
  mutate(summary = map(montant_dep, my_resume)) %>% 
  unnest(summary)
```

