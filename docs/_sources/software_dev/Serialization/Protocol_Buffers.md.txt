# Serialization: Protocol Buffer

## What are Protocol Buffers?

> Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for **serializing** structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.

## How do they work?

> **.proto files:** \
> You specify how you want the information you're serializing to be structured by defining protocol buffer message types in .proto files. 

> **Protocol buffer messages:**\
>Each protocol buffer message is a small logical record of information, containing a series of name-value pairs.\
> The message format is simple – each message type has one or more uniquely numbered fields, and each field has a name and a value type, where value types can be numbers (integer or floating-point), booleans, strings, raw bytes, or even (as in the example above) other protocol buffer message types, allowing you to structure your data hierarchically. You can specify optional fields, required fields, and repeated fields.

> **Example:**\
 Here's a very basic example of a .proto file that defines a message containing information about a person.

    message Person {
    required string name = 1;
    required int32 id = 2;
    optional string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        required string number = 1;
        optional PhoneType type = 2 [default = HOME];
    }

    repeated PhoneNumber phone = 4;
    }

>PS: This message is encoded to the protocol buffer binary format (the text format above is just a convenient human-readable representation for debugging and editing)

## Compiling .proto file to generate classes in desired programming language:
> Once you've defined your messages, you run the protocol buffer compiler for your application's language on your .proto file to generate data access classes. These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole structure to/from raw bytes\

> **Example Continued:** For instance, if your chosen language is C++, running the compiler on the above example will generate a class called Person. 

## Using the classes generated by protocol buffer compiler:
> **Example Continued:**
You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You might then write some code like this:
```cpp
Person person;
person.set_name("John Doe");
person.set_id(1234);
person.set_email("jdoe@example.com");
fstream output("myfile", ios::out | ios::binary);
person.SerializeToOstream(&output);
```

Then, later on, you could read your message back in:
```cpp
fstream input("myfile", ios::in | ios::binary);
Person person;
person.ParseFromIstream(&input);
cout << "Name: " << person.name() << endl;
cout << "E-mail: " << person.email() << endl;
```

## Adding new fields to existing protocol buffers
> You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about breaking existing code.

## Sending protobuf messages on pubsub:
> If you want to send a ProtoBuf message via the Publish API, you should do so by serializing it to a ByteString and then setting it as the message's data field.

## Astuces:
- compile cmd line 
> protoc -I C:\Users\Tonguz-lab-Mouse\Documents\VTL\Code\Greengo\greengo_driver_app\simple_map_layout\protos\ --dart_out=../lib/ topics/vehicle_positions/VehiclePosition.proto geographic/Position.proto vehicle/VehicleType.proto --plugin "pub run protoc_plugin"
- No required and optional fields in proto3