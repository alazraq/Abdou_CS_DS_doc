%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}




\title{Greengo Documentation}
\date{Apr 06, 2020}
\release{}
\author{VTL LLC}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Greengo is a centralized, cloud, vehicle tracking and traffic light recommendation system.

This documentation contains documentation whose scope is global to Greengo.
Documentation for specific services will be found in the doc folder of the service they document, not in these pages.


\chapter{Blog}
\label{\detokenize{blog/index:blog}}\label{\detokenize{blog/index::doc}}

\section{2019}
\label{\detokenize{blog/2019/index:id1}}\label{\detokenize{blog/2019/index::doc}}

\subsection{12}
\label{\detokenize{blog/2019/12/index:id1}}\label{\detokenize{blog/2019/12/index::doc}}

\subsubsection{What is Greengo?}
\label{\detokenize{blog/2019/12/what_is_greengo:what-is-greengo}}\label{\detokenize{blog/2019/12/what_is_greengo::doc}}
Let‚Äôs start at the beginning!

Greengoüö¶is a VTL project that aims to provide real-time, centrally optimized traffic lights at low-cost for the general public.

In short, the system will leverage on phones to send real-time vehicle localization information to a centralized cloud backend and produce optimized traffic lights based on those information. The system can work even with partial penetration (i.e. even if not all drivers are running the Greengo app) by making physical traffic lights display the traffic light values computed by Greengo.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{system_architecture_schema}.png}
\caption{Architecture of Greengo}\label{\detokenize{blog/2019/12/what_is_greengo:id1}}\end{figure}


\subsubsection{üìÑ A Complete Documentation!}
\label{\detokenize{blog/2019/12/documentation:a-complete-documentation}}\label{\detokenize{blog/2019/12/documentation::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{documentation}.png}
\end{figure}

Because the Greengo project is complex and purposefully highly fragmented (that is the reason to use a microservice architecture in the first place), having an efficient documentation rapidly became strongly needed to \sphinxstylestrong{keep the development process efficient}.

A complete documentation system was put in place. It allows to \sphinxstylestrong{rapidly and efficiently write documentation} using RestructuredText. Upon committing on the master branch of the BitBucket \sphinxcode{\sphinxupquote{greengo\_documentation}} repository, the code is automatically compiled into a website using Sphinx, and then deployed on Google Cloud as a standard website.

The website is access-protected to only make the documentation available to listed account. The documentation is available \sphinxhref{https://greengo-documentation.appspot.com/index.html}{here} (if you have a white-listed account only). If you want to gain access to it, feel free to send an email to \sphinxhref{mailto:yves.zumbach@virtualtrafficlights.com}{yves.zumbach@virtualtrafficlights.com}. You can also access a \sphinxhref{https://storage.cloud.google.com/greengo\_newsletter/2019-12/greengo.pdf}{PDF version of the whole documentation}.


\subsubsection{Microservice Under Focus: Data Preprocessing}
\label{\detokenize{blog/2019/12/data_preprocessing:microservice-under-focus-data-preprocessing}}\label{\detokenize{blog/2019/12/data_preprocessing::doc}}
An In-Depth Look at a Microservice

The \sphinxhref{https://greengo-documentation.appspot.com/microservice\_map\_preprocessing/index.html}{Data Preprocessing} (\sphinxhref{https://bitbucket.org/vtl\_team/greengo\_data\_preprocessing/src/dev/}{BitBucket repository}) microservice‚Äôs task is to \sphinxstylestrong{precompute the data needed by the various microservices across Greengo}. Below is an infographics that details its working.

This fundamental microservice was implemented by Kyle (which unfortunately left VTL to seek new horizons). The module is operational and was executed on the entire map of Switzerland, results are currently stored online for the other microservices to download; that is several gigabytes of data.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{data_preprocessing_infographics}.png}
\end{figure}


\subsubsection{Progress on the Driver Appüì±!}
\label{\detokenize{blog/2019/12/driver_app:progress-on-the-driver-app}}\label{\detokenize{blog/2019/12/driver_app::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{driver_app}.png}
\end{figure}

What is the current state of affair of the Greengo Driver App (here is the BitBucket repository)?

The driver app can subscribe to the phone GPS data, display an interactive map that is automatically centered and rotated.

Authentication screens are working using Firebase as backend for the authentication process.

Implemented in Flutter (by Google), it provides native performances and can be deployed to Android and iOS using only one code base.

The app can already send data to Greengo. It does it by directly publishing on the appropriate PubSub channel.
Receiving data directly from Pub/Sub is not well-suited for an app, therefore data are instead received from a third-party real-time services provider: Pusher.

The code that handles receiving data from Greengo needs to be completed. Still missing is the code that will make the app automatically listen to the messages for the intersections toward which the vehicle is heading, store those messages, compute what is the current traffic light to display on screen, show it and finally delete the outdated message, all in real-time.


\section{2020}
\label{\detokenize{blog/2020/index:id1}}\label{\detokenize{blog/2020/index::doc}}

\subsection{01}
\label{\detokenize{blog/2020/01/index:id1}}\label{\detokenize{blog/2020/01/index::doc}}

\subsubsection{Contract Scheduler and Contract Maker}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:contract-scheduler-and-contract-maker}}\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{contract_maker_vs_contract_scheduler}.png}
\end{figure}

This article walks you through two core services of Greengo: the contract scheduler and the contract maker. It further elaborates on why we chose to split them.

\sphinxstylestrong{üí° A quick reminder - Contracts:} A contract is a Greengo specific abstraction. It is an object that fully describes the behavior of an intersection between two timestamps. So it contains the color of the traffic light for all possible turns for all instants between the two timestamps.

Alright, so what are the Contract Scheduler and Maker services?


\paragraph{‚åö Contract Scheduler}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:contract-scheduler}}
\sphinxstylestrong{Task:} Send triggers when new contracts needs to be created.

The contract scheduler keeps a list of all intersection and the duration until which they do have a contract defined. Before the intersection becomes ‚Äúout-of-contract‚Äù, the service sends a trigger on Google PubSub containing the intersection for which a new contract should be created and the start and end time that the contract must have.

In a word, it schedules contract creation.


\paragraph{üìù Contract Maker}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:contract-maker}}
\sphinxstylestrong{Task:} Upon receiving a contract creation trigger, it creates an optimized contract for an intersection.

The contract maker, upon receiving a trigger for an intersection will fetch the relevant information:
\begin{itemize}
\item {} 
What is the configuration of the intersection: what are the connected lanes and what are the valid turns.

\item {} 
What is the traffic load on each of the connected lanes (fetched from the üöó traffic service that is responsible for keeping such a mapping up-to-date).

\item {} 
What are the contract already defined for the intersection.

\end{itemize}

It will then compute a contract that maximizes the traffic flow and publish this contract on Google PubSub.


\paragraph{Technical Requirements}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:technical-requirements}}
Implementing the above requires at least the following:
\begin{itemize}
\item {} 
Having a working üöó traffic microservice.

\item {} 
Keeping the previous contract in a fast write-once-read-many database (think DynamoDB or similar).

\item {} 
Developing a communication protocol between the contract scheduler and the contract maker so that the contract scheduler knows for sure when the contract is created and triggers the creation of the contract again if it failed the first time.

\end{itemize}

Of course, those are no easy requirements, which is why we decided to simplify them for the alpha version.


\paragraph{‚ö†Ô∏è Alpha Version}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:alpha-version}}
For the alpha version of Greengo, the team decided to simplify a bit the formal requirements above:
\begin{itemize}
\item {} 
The contract maker always produce the same fixed-length contract for a given intersection (thus behaving like a ‚Äústupid‚Äù traffic light). Kyle was able to create such predefined contracts using SUMO. Thanks to this simplification, the contract maker does not need to query the intersection configuration, nor the traffic, nor the previous contracts. So no need for a traffic service, nor an intersection configuration service nor a write-once-read-many fast database, Yippee!!

\item {} 
The contract scheduler does not check that the contract was successfully created. It sends the trigger then assumes that everything works fine.

\end{itemize}

Of course, before putting the system in production it will be an absolute requirement to implement the full requirements as they are safety critical, but in the mean time it will allow the Greengo team to write a working demo version on which preliminary tests can be run.


\paragraph{üî® Current Status}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:current-status}}
The current state of affairs is approximately the following.
\begin{itemize}
\item {} 
No traffic service implemented as it is not required yet.

\item {} 
A simplified contract scheduler was created. It sends contract creation triggers at fixed intervals only. We will need to make it a bit more clever even for the alpha version: it will need to only send triggers after the contract for an intersection is fully elapsed.

\item {} 
Currently working on the contract maker which is not functional yet.

\end{itemize}


\paragraph{Splitting the Two Services}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:splitting-the-two-services}}
Alright, but why split the two services? Why not built the two of them as a single service and save some hassle!

Well, micro-service architecture is about micro-services. Having small services with a well-defined single task allow them to stay maintainable, testable and makes it easy to improve them independently. When you come to think about it, the contract scheduler and maker are core services of Greengo as they are critical elements when it comes to producing added-value compared to regular traffic lights! So it is foreseeable that we will invest quite some time on making those two services better. Thus being able to make them evolve independently is strongly desirable.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{future_plans}.png}
\end{figure}


\paragraph{Looking Toward the Future}
\label{\detokenize{blog/2020/01/contract_maker_vs_contract_scheduler:looking-toward-the-future}}
Here are some of the ideas that we might want to implement in the future regarding contracts.

For the contract scheduler:
\begin{itemize}
\item {} 
Schedule different contract length depending on the time of day (night traffic, being a lot less dense, could be optimized so that drivers always see green).

\item {} 
Schedule different contract length for each intersection based on learned traffic intensity.

\item {} 
Send the trigger more or less ahead of the current contract expiration time based on learned trigger-to-phone-reception latency. Triggering the contract creation later, makes for more optimized contracts, but can be a security issue if the contracts are received too late by the vehicles.

\end{itemize}

For the contract maker:
\begin{itemize}
\item {} 
Optimize contract creation process based on learned traffic patterns and past efficiency.

\end{itemize}

Most of the above improvements can naturally be implemented using neural networks. But putting all these systems in one single service makes for a huge monolithic service that will be both impossible to understandable and extremely hard to maintain. That is the reason we are splitting the two services now.


\subsubsection{Vehicle Localization Service}
\label{\detokenize{blog/2020/01/vehicle_localization:vehicle-localization-service}}\label{\detokenize{blog/2020/01/vehicle_localization::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{earth}.jpeg}
\end{figure}

\sphinxstylestrong{‚ùì What is it?} The localization is one of the core components of Greengo. It is tasked with mapping vehicles to the road they are on and the intersection they are heading toward.

\sphinxstylestrong{‚ö†Ô∏è Biggest issues ?} The system needs to be able to scale to millions of vehicles, compute the values in milliseconds at most and it needs to be able to handle all roads on Earth without too much manual work from the developers (so hard coding the streets is not an option here!).

\sphinxstylestrong{Bigger picture.} A picture of Greengo‚Äôs global architecture is given below to better situate the vehicle localization service.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{system_architecture_schema1}.png}
\caption{Greengo‚Äôs Architecture}\label{\detokenize{blog/2020/01/vehicle_localization:id1}}\end{figure}

\sphinxstylestrong{üìù Interface Specification.} The service receives the list of previous GPS coordinates from the vehicles and needs to convert them to a tuple of identifier containing the previous intersection id and the next intersection id.

\sphinxstylestrong{‚öôÔ∏è How did we implement it?} GPS coordinates are received through Google PubSub. Those coordinates are measured by the vehicle and can thus be noisy. Therefore, the module ‚Äúmap matches‚Äù the coordinates, which is the process of fitting a track to the roads of the map. This process is probabilistic (so it can sometimes produce wrong results‚Ä¶) and is done by a server that is deployed alongside the localization: an instance of the Open Source Routing Machine server (OSRM in short). The output of a map matching query to this server actually also contains the Open Street Map ids of the nodes that the path crosses.

Using those ids, the localization module computes the road id and the next intersection id using data stored on Google Storage by the map data preprocessing module.

The computed values are then sent back to Google PubSub to be used by other modules across Greengo.

An overview of the architecture of the module is given below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{localization_architecture}.png}
\end{figure}

\sphinxstylestrong{Why did we do it this way?} Greengo requires map data to work. The best quality data open source provider is Open Street Map and many other open source projects like SUMO and OSRM use OSM data, so it was kind of an obvious choice to go with OSM. The other option would have been to use google maps data, but querying the Google Maps API at Greengo‚Äôs scale was economically not viable.

Implementing map matching (or any map related feature such as routing or estimating travel distances or time) is a really complex problem, so the rational decision was to use a library that already did it for us. We could not find any Java or Scala library that would perform this. We compared several different open source server that performed those services and OSRM was the best choice among them.

\sphinxstylestrong{üî¢ A few stats about the service.}

Language: Scala.

\# Line of codes: around 1100.

Testing:
\begin{itemize}
\item {} 
Basic testing done manually (and it seems to work üòâ).

\item {} 
A few unit tests are written, but waiting for the code to stabilize a little bit more before writing them.

\item {} 
Integration tests are written but still need to be deployed (You will probably hear about those next month).

\end{itemize}


\subsubsection{Greengo Branding}
\label{\detokenize{blog/2020/01/branding:greengo-branding}}\label{\detokenize{blog/2020/01/branding::doc}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{branding}.jpg}
\end{figure}

\sphinxstylestrong{Design has never been more important than nowadays.} Having a strong visual identity allows to be recognized and remembered more easily among the multitude of alternative that the web can offer.

For that reason, \sphinxstylestrong{design guidelines} for Greengo were created, so that all Greengo designs are consistent and memorable.
It was decided to give Greengo a young and dynamic look.
Therefore, colors are mainly saturated and defined so that they have enough contrast with both black and white (they have values close to the maximum).

Some care was taken to make the deployment of the guidelines and graphical assets automatic, thus making it really easy to apply those guidelines (and change them).
The guidelines are summarized below.


\paragraph{Colors palette}
\label{\detokenize{blog/2020/01/branding:colors-palette}}
A color palette is a list of colors that are to be used when creating graphical elements.

You actually already know two of the colors from the Greengo palette: the Greengo \sphinxstylestrong{main color} is the green used for the background of the header of this email.
The alternate main color is the green used on the left of the Greengo banner.



\sphinxstyleemphasis{\#Emerald}

Primary

Hex: \sphinxcode{\sphinxupquote{\#13ef80}}

RGB: \sphinxcode{\sphinxupquote{rgb(19, 239, 128)}}

\sphinxstyleemphasis{\#Lime Soap}

Primary Light

Hex: \sphinxcode{\sphinxupquote{\#6bffb1}}

RGB: \sphinxcode{\sphinxupquote{rgb(107, 255, 177)}}

\sphinxstyleemphasis{\#Lush Forest}

Primary Dark

Hex: \sphinxcode{\sphinxupquote{\#00bb51}}

RGB: \sphinxcode{\sphinxupquote{rgb(0, 187, 81)}}

\sphinxstyleemphasis{\#Wild Caribbean Green}

Primary Alternate

Hex: \sphinxcode{\sphinxupquote{\#1dd1a1}}

RGB: \sphinxcode{\sphinxupquote{rgb(29, 209, 161)}}

A secondary color was also defined.
It is an amethyst purple.
Interface nowadays often contain two colors; those that designed applications for phones might know this; this is also one of the core ideas behind Material design, the design principles by Google that are used for most of Android and web applications.
The Greengo main and secondary color are further declined in three version: light, normal and dark.
Standard colors for red, orange, yellow and blue were created as those colors are often use in user interfaces.

\sphinxstyleemphasis{\#Amethyst}

Secondary

Hex: \sphinxcode{\sphinxupquote{\#c442ff}}

RGB: \sphinxcode{\sphinxupquote{rgb(196, 66, 255)}}

Lotus Pink

Secondary Light

Hex: \sphinxcode{\sphinxupquote{\#fb78ff}}

RGB: \sphinxcode{\sphinxupquote{rgb(251, 120, 255)}}

Deep Purple

Secondary Dark

Hex: \sphinxcode{\sphinxupquote{\#8e00cb}}

RGB: \sphinxcode{\sphinxupquote{rgb(142, 0, 203)}}


\paragraph{Fonts}
\label{\detokenize{blog/2020/01/branding:fonts}}
Fonts can be categorized according to many properties.
One of the most defining one is whether the font has \sphinxhref{https://en.wikipedia.org/wiki/Serif}{serifs}.
A serif is a small line or stroke attached to the end of the letters.
The most well known example of serif font is probably \sphinxhref{https://en.wikipedia.org/wiki/Times\_New\_Roman}{Times New Roman}.

Font without serifs are called sans fonts (which comes from the french ‚ÄúSans‚Äù which means ‚Äúwithout‚Äù for ‚Äúwithout serif‚Äù).
The most well known sans fonts are probably \sphinxhref{https://en.wikipedia.org/wiki/Arial}{Arial} and \sphinxhref{https://en.wikipedia.org/wiki/Helvetica}{Helvetica Neue}.

One can note that \sphinxstyleemphasis{all} fonts above are \sphinxhref{https://en.wikipedia.org/wiki/Monotype\_Imaging}{proprietary} and their usage is legally limited.

Another important font category are monospaced fonts.
Those fonts are designed so that all characters have the same width.
They were created for typewriter as the typewriter advanced the paper always by the same width after typing a character.
Nowadays they are mostly used to display code; for example all code editor use monospaced fonts which is practical when aligning characters is important such as in languages that are indented.

The design guidelines for Greengo specify two \sphinxstylestrong{sans serif} fonts (Open Sans and Roboto, NB: this email is in Open Sans).
Below is an example of what Open Sans looks like.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{open_sans}.png}
\end{figure}

The \sphinxstylestrong{serif font} to use for Greengo is Roboto Slab.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{roboto_slab}.png}
\end{figure}

The \sphinxstylestrong{monospaced font} for Greengo is Source Code Pro.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{source_code_pro}.png}
\end{figure}


\paragraph{Logo, Heading and Banner}
\label{\detokenize{blog/2020/01/branding:logo-heading-and-banner}}
The logo was created as an svg file (the shoe with the leaf).
The title font for Greengo is a custom made font, so no one has the same (Actually only the characters G, r, e, n and o are defined üòã).

Three graphical assets are defined: the logo, the heading (the Greengo title on a background) and the banner (the logo plus the Greengo title).
Below are given two variants of the banner.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{logo_1}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{logo_2}.png}
\end{figure}


\paragraph{Automation}
\label{\detokenize{blog/2020/01/branding:automation}}
All the design assets are grouped in a git repository: \sphinxcode{\sphinxupquote{greengo\_design}} (\sphinxhref{https://bitbucket.org/vtl\_team/greengo\_design/src}{here}).

They are automatically generated from their definition using a python script that generates PDF files (using LaTeX), then convert those vector files to various PNG images.
Note that PNG is the recommended format for such images.
The script generates images in five sizes (100px, 200px, 400px, 800px and 1600px) for all variants of the logo, banner and heading (of which there are five of each).

\sphinxstylestrong{A single command thus generates approximately 120 different images and 3 font formats} (web fonts are not encoded using the same format as desktop fonts, thus the Greengo font is distributed in three different formats).

Some further continuous deployment scripting allows \sphinxstylestrong{those assets to be automatically deployed on Google Storage} when committing on specific branches of the design repository and are thus \sphinxhref{https://storage.cloud.google.com/design\_assets/1.0.0/img/logo/logo-gradient-on-black-high-400-web.png}{publicly available on the web}.
This makes it easy as a breeze to include those assets in web content (for example the Greengo documentation) or some web dashboard that we might code one day.


\chapter{System Architecture}
\label{\detokenize{system_architecture:system-architecture}}\label{\detokenize{system_architecture::doc}}
The following graph give an idea of the architecture of the system.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{system_architecture_schema2}.png}
\caption{Global overview of the architecture of Greengo}\label{\detokenize{system_architecture:id1}}\end{figure}


\section{Services Rundown}
\label{\detokenize{system_architecture:services-rundown}}

\subsection{Driver App}
\label{\detokenize{system_architecture:driver-app}}
A mobile app available on all devices that connects to Greengo, sends information like geolocation, receives contracts concluded for nearby intersections.
The app displays information to the driver about the next intersection‚Äôs traffic light and maybe additional content like speed limitations, etc.


\subsection{Google Pub/Sub}
\label{\detokenize{system_architecture:google-pub-sub}}
Google Pub/Sub is an industry standard for handling high throughput, low latency messages.
It is a message broker that implement the publisher/subscriber model and provide support for multiple functionalities including messages divided into topics, storage of messages, various reading policies, etc.

The role of this framework in Greengo will be to unify communication channels between the various services.


\subsection{Pusher}
\label{\detokenize{system_architecture:pusher}}
Third-party service that provides an API to build large scale real-time application.


\subsection{Authentication}
\label{\detokenize{system_architecture:authentication}}
Users authenticate to the authentication server before being able to access Greengo.
Implemented using Firebase.


\subsection{Vehicle Localization}
\label{\detokenize{system_architecture:vehicle-localization}}
Listen to the stream of vehicle positions and produces a stream containing the previous and the next intersection of the vehicle.


\subsection{Contract Scheduler}
\label{\detokenize{system_architecture:contract-scheduler}}
The contract scheduler sends triggers to the contract maker every time a new contract needs to be created for any ontersection handled by the Greengo system.


\subsection{Contract Maker}
\label{\detokenize{system_architecture:contract-maker}}
The contract maker, upon receiving a trigger from the contract scheduler, creates a contract for the intersection to which the trigger applies.


\subsection{Localization Dispatcher}
\label{\detokenize{system_architecture:localization-dispatcher}}
The localization dispatcher sends localization information as produced by the vehicle localization service to the appropriate driver app using pusher channels.


\subsection{Contract Dispatcher}
\label{\detokenize{system_architecture:contract-dispatcher}}
The contract dispatcher sends each contract to a pusher channel corresponding to the contract‚Äôs intersection.
The driver apps then subscribe to the channel of the intersection that interests them and are so able to receive the contracts.


\subsection{Map Preprocessing}
\label{\detokenize{system_architecture:map-preprocessing}}
Preprocesses Open Street Map maps to produce the various mappings needed by the microservices in Greengo.


\section{Future Architecture}
\label{\detokenize{system_architecture:future-architecture}}
This section details the future architecture (after version alpha) of the services necessary to generate contracts.


\subsection{Traffic}
\label{\detokenize{system_architecture:traffic}}
Aggregate the messages from ‚Äòvehicle\_localization‚Äô in a database (probably Cassandra) by intersection and approach.
The main utility of this will be to make informed traffic light decision in the contract maker.


\subsection{Billing}
\label{\detokenize{system_architecture:billing}}
The service that measure how much a client should be billed.


\subsection{Decision Neural Network}
\label{\detokenize{system_architecture:decision-neural-network}}
Traffic light decisions might be delegated to a neural network in the future.


\subsection{Greengo Admin Space}
\label{\detokenize{system_architecture:greengo-admin-space}}
The Greengo admin space will be a website that will allow customers to retrieve useful information about the usage of Greengo: number of connected users, traffic patterns, etc. Additional paid functionalities could be implemented (like support for emergency vehicles).


\subsection{Possible Pitfalls}
\label{\detokenize{system_architecture:possible-pitfalls}}
Here is a list of the possible pitfalls that will have to be addressed:
\begin{itemize}
\item {} 
All clocks in the system must be synchronized (safety critical)

\item {} 
How do we check that two instances of the contract maker don‚Äôt receive the same pubsub message and schedule the same contract? Would that really be a problem?

\end{itemize}


\chapter{Software Engineering}
\label{\detokenize{software_engineering:software-engineering}}\label{\detokenize{software_engineering::doc}}
Following good practices are used for Greengo:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Use git and the GitFlow workflow.

\item {} 
Use semantic versioning (see {\hyperref[\detokenize{software_engineering:semantic-versioning}]{\sphinxcrossref{\DUrole{std,std-ref}{Semantic Versioning}}}}).

\item {} 
Document a lot (see {\hyperref[\detokenize{building_a_microservice:service-documentation}]{\sphinxcrossref{\DUrole{std,std-ref}{Documenting a Service}}}}).

\end{enumerate}

Following good practices are \sphinxstylestrong{highly recommended}:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Use code reviews before merging to \sphinxtitleref{dev} and \sphinxtitleref{release} branches.

\item {} 
Use automated testing and deployment (for example by using Bitbucket pipelines).

\item {} 
Use automatic style checking tools.

\end{enumerate}


\section{Semantic Versioning}
\label{\detokenize{software_engineering:semantic-versioning}}\label{\detokenize{software_engineering:id1}}
From the official \sphinxhref{https://semver.org/}{semantic versioning website}:

Given a version number MAJOR.MINOR.PATCH, increment the:
\begin{itemize}
\item {} 
MAJOR version when you make incompatible API changes,

\item {} 
MINOR version when you add functionality in a backwards-compatible manner, and

\item {} 
PATCH version when you make backwards-compatible bug fixes.

\end{itemize}


\chapter{Taxonomy and Serialization}
\label{\detokenize{taxonomy_serialization:taxonomy-and-serialization}}\label{\detokenize{taxonomy_serialization:taxonomy-serialization}}\label{\detokenize{taxonomy_serialization::doc}}
This page describes the name of various concepts and how they should be serialized and parsed.
It is highly recommended to use the identical names to describe the identical concepts across services, so as to make it easier for developers to switch from one project to another.


\section{Identifiers}
\label{\detokenize{taxonomy_serialization:identifier}}\label{\detokenize{taxonomy_serialization:identifiers}}
Identifiers are used to uniquely identify ‚Äúthings‚Äù.

Identifiers are serialized to \sphinxstyleemphasis{strings}.
The strings themselves generally encode the value of 64-bits signed integers (\sphinxcode{\sphinxupquote{long}} in Java, \sphinxcode{\sphinxupquote{Int64}} in Javascript, \sphinxcode{\sphinxupquote{int}} in Python3) but this must not always be the case.
Valid identifiers are positive only.
0 is a valid identifier.
Negative values are reserved for temporary identifiers or to indicate that an error occurred.

\begin{sphinxadmonition}{warning}{Warning:}
When using JSON to encode {\hyperref[\detokenize{taxonomy_serialization:identifier}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers}}}}, always serialize them as strings (not integers).
This is needed because Javascript is unable to handle 64 bit unsigned integers using its standard \sphinxcode{\sphinxupquote{Number}} type (which is what you get from the json parsing library when you decode a number).
\end{sphinxadmonition}


\subsection{UserId}
\label{\detokenize{taxonomy_serialization:userid}}\label{\detokenize{taxonomy_serialization:user-id}}
Uniquely identifies a user.


\subsection{VehicleId}
\label{\detokenize{taxonomy_serialization:vehicleid}}\label{\detokenize{taxonomy_serialization:vehicle-id}}
Uniquely identifies a vehicle.


\subsection{RoadId}
\label{\detokenize{taxonomy_serialization:roadid}}\label{\detokenize{taxonomy_serialization:road-id}}
Uniquely identifies a road.


\subsection{IntersectionId}
\label{\detokenize{taxonomy_serialization:intersectionid}}\label{\detokenize{taxonomy_serialization:intersection-id}}
Uniquely identifies an intersection.


\subsection{TrafficLightPhaseId}
\label{\detokenize{taxonomy_serialization:trafficlightphaseid}}\label{\detokenize{taxonomy_serialization:traffic-light-phase-id}}
Uniquely identifies a {\hyperref[\detokenize{taxonomy_serialization:traffic-light-phase}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Phase}}}}.


\subsection{ContractId}
\label{\detokenize{taxonomy_serialization:contractid}}\label{\detokenize{taxonomy_serialization:contract-id}}
Uniquely identifies a {\hyperref[\detokenize{taxonomy_serialization:contract}]{\sphinxcrossref{\DUrole{std,std-ref}{Contract}}}}.


\section{Time}
\label{\detokenize{taxonomy_serialization:time}}

\subsection{Moment}
\label{\detokenize{taxonomy_serialization:moment}}\label{\detokenize{taxonomy_serialization:id1}}
A moment is a specific point on the timeline; it is identical for everyone, wherever you stand on Earth (by opposition to a date + hour which can represent very different moments depending on the time zone you are in).
It is encoded as the integer number of elapsed milliseconds since the UNIX epoch (1 January 1970 00:00:00 UTC), with leap seconds ignored.

Additionally, a time zone can be provided.

Following are code samples to obtain the current moment and their encodings:

\sphinxstylestrong{Javascript}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{const} \PYG{n+nx}{now} \PYG{o}{=} \PYG{k}{new} \PYG{n+nb}{Date}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{const} \PYG{n+nx}{millisSinceEpoch} \PYG{o}{=} \PYG{n+nx}{now}\PYG{p}{.}\PYG{n+nx}{getTime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{const} \PYG{n+nx}{momentFromMillisSinceEpoch} \PYG{o}{=} \PYG{k}{new} \PYG{n+nb}{Date}\PYG{p}{(}\PYG{n+nx}{millisSinceEpoch}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{Python3}:
One might want to look into the pendulum library for extended functionalities.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{n}{now} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{millisSinceEpoch} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{now} \PYG{o}{*} \PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{datetime}
\PYG{n}{const} \PYG{n}{momentFromMillisSinceEpoch} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{datetime}\PYG{o}{.}\PYG{n}{fromtimestamp}\PYG{p}{(}\PYG{n}{millisSinceEpoch} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Java}:
See this Stackoverflow \sphinxhref{https://stackoverflow.com/questions/32437550/whats-the-difference-between-instant-and-localdatetime}{thread} for detailed explanations of the classes available in Java.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.time.Instant}\PYG{o}{;}
\PYG{n}{Instant} \PYG{n}{now} \PYG{o}{=} \PYG{n}{Instant}\PYG{o}{.}\PYG{n+na}{now}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{k+kt}{long} \PYG{n}{millisSinceEpoch} \PYG{o}{=} \PYG{n}{now}\PYG{o}{.}\PYG{n+na}{toEpochMilli}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
\PYG{n}{Instant} \PYG{n}{momentFromMillisSinceEpoch} \PYG{o}{=} \PYG{n}{Instant}\PYG{o}{.}\PYG{n+na}{ofEpochMilli}\PYG{o}{(}\PYG{n}{millisSinceEpoch}\PYG{o}{)}\PYG{o}{;}
\end{sphinxVerbatim}


\section{Geospatial Data}
\label{\detokenize{taxonomy_serialization:geospatial-data}}
By convention, latitudes are given first, longitudes are given second.


\subsection{Latitude}
\label{\detokenize{taxonomy_serialization:latitude}}\label{\detokenize{taxonomy_serialization:id2}}
A geographic coordinate that specifies the north\textendash{}south position of a point on the Earth‚Äôs surface relatively to the Equator.
A latitude is an angle which ranges from 90¬∞ (included) at the north pole to -90¬∞ (included) at the south pole, 0¬∞ being the Equator.

Encoded as a floating-point value in degrees.


\subsection{Longitude}
\label{\detokenize{taxonomy_serialization:longitude}}\label{\detokenize{taxonomy_serialization:id3}}
A geographic coordinate that specifies the east\textendash{}west position of a point on the Earth‚Äôs surface.
A longitude is an angle.
The 0¬∞ longitude is defined as the meridian of greenwich.
Eastward longitude have values ranging from 0¬∞ to 180¬∞ (included).
Westward longitudes have values ranging from 0¬∞ to -180¬∞ (included).

Encoded as a floating-point value in degrees.


\subsection{Heading}
\label{\detokenize{taxonomy_serialization:heading}}\label{\detokenize{taxonomy_serialization:id4}}
An angle giving a direction of travel, specified in degrees counting clockwise relative to the true north.
Encoded as a floating-point value between 0 included and 360 included.


\subsection{Speed}
\label{\detokenize{taxonomy_serialization:speed}}\label{\detokenize{taxonomy_serialization:id5}}
A positive floating-point value.
Speeds are always handled in meters per seconds.
Only user fronting applications might translate them to other units like kilometers per hours or miles per hours.


\subsection{Altitude}
\label{\detokenize{taxonomy_serialization:altitude}}\label{\detokenize{taxonomy_serialization:id6}}
Height of a position in meters above the ellipsoid.
Serialized as a floating-point positive value in meters.


\subsection{Coordinates}
\label{\detokenize{taxonomy_serialization:coordinates}}\label{\detokenize{taxonomy_serialization:coordinate}}
A set of properties that describe a geographic position.

It \sphinxstyleemphasis{must} contain:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{latitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:latitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Latitude}}}}.

\item[{\sphinxcode{\sphinxupquote{longitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:longitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Longitude}}}}.

\end{description}

It \sphinxstyleemphasis{can} but must not contain:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{timestamp}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:moment}]{\sphinxcrossref{\DUrole{std,std-ref}{Moment}}}}.

\item[{\sphinxcode{\sphinxupquote{heading}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:heading}]{\sphinxcrossref{\DUrole{std,std-ref}{Heading}}}}.

\item[{\sphinxcode{\sphinxupquote{speed}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:speed}]{\sphinxcrossref{\DUrole{std,std-ref}{Speed}}}}.

\item[{\sphinxcode{\sphinxupquote{accuracy}}:}] \leavevmode
Accuracy level of the latitude and longitude coordinates in meters.
Serlialized as a floating-point value.

\item[{\sphinxcode{\sphinxupquote{altitude}}:}] \leavevmode
An {\hyperref[\detokenize{taxonomy_serialization:altitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Altitude}}}}.

\item[{\sphinxcode{\sphinxupquote{altitudeAccuracy}}:}] \leavevmode
Accuracy level of the altitude coordinate in meters.
Serlialized as a floating-point value.

\end{description}


\subsection{Position}
\label{\detokenize{taxonomy_serialization:position}}\label{\detokenize{taxonomy_serialization:id7}}
A set of properties that describe a static geographic position.

It \sphinxstyleemphasis{must} contain the following information:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{latitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:latitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Latitude}}}}.

\item[{\sphinxcode{\sphinxupquote{longitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:longitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Longitude}}}}.

\item[{\sphinxcode{\sphinxupquote{timestamp}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:moment}]{\sphinxcrossref{\DUrole{std,std-ref}{Moment}}}}.

\end{description}

It \sphinxstyleemphasis{can} but must not contain:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{heading}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:heading}]{\sphinxcrossref{\DUrole{std,std-ref}{Heading}}}}.

\item[{\sphinxcode{\sphinxupquote{speed}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:speed}]{\sphinxcrossref{\DUrole{std,std-ref}{Speed}}}}.

\item[{\sphinxcode{\sphinxupquote{accuracy}}:}] \leavevmode
Accuracy level of the latitude and longitude coordinates in meters.
Serlialized as a floating-point value.

\item[{\sphinxcode{\sphinxupquote{altitude}}:}] \leavevmode
An {\hyperref[\detokenize{taxonomy_serialization:altitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Altitude}}}}.

\item[{\sphinxcode{\sphinxupquote{altitudeAccuracy}}:}] \leavevmode
Accuracy level of the altitude coordinate in meters.
Serlialized as a floating-point value.

\end{description}


\subsection{Waypoint}
\label{\detokenize{taxonomy_serialization:waypoint}}\label{\detokenize{taxonomy_serialization:id8}}
A set of properties that describe a dynamic geographic position.

It \sphinxstyleemphasis{must} contain the following information:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{latitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:latitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Latitude}}}}.

\item[{\sphinxcode{\sphinxupquote{longitude}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:longitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Longitude}}}}.

\item[{\sphinxcode{\sphinxupquote{timestamp}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:moment}]{\sphinxcrossref{\DUrole{std,std-ref}{Moment}}}}.

\item[{\sphinxcode{\sphinxupquote{heading}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:heading}]{\sphinxcrossref{\DUrole{std,std-ref}{Heading}}}}.

\item[{\sphinxcode{\sphinxupquote{speed}}:}] \leavevmode
A {\hyperref[\detokenize{taxonomy_serialization:speed}]{\sphinxcrossref{\DUrole{std,std-ref}{Speed}}}}.

\end{description}

It \sphinxstyleemphasis{can} but must not contain:
\begin{description}
\item[{\sphinxcode{\sphinxupquote{accuracy}}:}] \leavevmode
Accuracy level of the latitude and longitude coordinates in meters.
Serlialized as a floating-point value.

\item[{\sphinxcode{\sphinxupquote{altitude}}:}] \leavevmode
An {\hyperref[\detokenize{taxonomy_serialization:altitude}]{\sphinxcrossref{\DUrole{std,std-ref}{Altitude}}}}.

\item[{\sphinxcode{\sphinxupquote{altitudeAccuracy}}:}] \leavevmode
Accuracy level of the altitude coordinate in meters.
Serlialized as a floating-point value.

\end{description}


\subsection{Track}
\label{\detokenize{taxonomy_serialization:track}}\label{\detokenize{taxonomy_serialization:id9}}
An ordered list of {\hyperref[\detokenize{taxonomy_serialization:waypoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Waypoint}}}}s describing a path.
Generally used to record a travelled path.


\subsection{Route}
\label{\detokenize{taxonomy_serialization:route}}\label{\detokenize{taxonomy_serialization:id10}}
An ordered list of {\hyperref[\detokenize{taxonomy_serialization:waypoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Waypoint}}}}s representing a series of turn points leading to a destination.
Often used to represent possible routes to take (as in Google Maps for example).


\section{Traffic}
\label{\detokenize{taxonomy_serialization:traffic}}

\subsection{Traffic Light Value}
\label{\detokenize{taxonomy_serialization:traffic-light-value}}\label{\detokenize{taxonomy_serialization:id11}}
A traffic light value is an abstraction that represent a traffic light color and an optional reason for that color.
It is serialized as a signed integer (on 32 bits).

Integer value to color mapping:
\begin{itemize}
\item {} 
-4000 to -3001: Blinking blue

\item {} 
-3000 to -2001: Blinking green

\item {} 
-2000 to -1001: Blinking orange

\item {} 
-1000 to -1: Blinking red

\item {} 
0 to 999: Red

\item {} 
1000 to 1999: Orange

\item {} 
2000 to 2999: Green

\item {} 
3000 to 3999: Blue

\end{itemize}

The \sphinxhref{./\_static/traffic\_light\_value\_causes.json}{following file} encode as JSON the reason of the colors.
In the mapping, an empty string means no particular reason.


\subsubsection{Color Meaning}
\label{\detokenize{taxonomy_serialization:color-meaning}}\begin{description}
\item[{Blinking Red}] \leavevmode
Used to symbolize critical errors.
For example, this color can indicate that no contracts were received so far for the next intersection.
Vehicles seeing this traffic light color should not attempt to cross the intersection but stop before it instead.

\item[{Blinking Orange}] \leavevmode
Used to symbolize non-critical warnings.
For example, this color can indicate an uninitialized traffic light which happens before the first synchronization between the driver app and the cloud.
It can also indicate a possible danger on the road like an accident.

\item[{Red}] \leavevmode
Vehicles are not allowed to cross the intersection.

\item[{Orange}] \leavevmode
Vehicles that can stop safely before the intersection should do so.
Orange is always followed by Red.

\item[{Green}] \leavevmode
Vehicles are allowed to cross the intersection.

\item[{Blue}] \leavevmode
Equivalent to displaying no traffic light information.
For example, used when there is no intersection nearby.

\end{description}


\subsection{Traffic Light Phase}
\label{\detokenize{taxonomy_serialization:traffic-light-phase}}\label{\detokenize{taxonomy_serialization:id12}}
A traffic light phase (abbreviated TL phase verbally, but always appear unabbreviated in code) is an abstraction that represents a \sphinxstyleemphasis{constant} state of a traffic light for a given intersection from a time \(t\) to a time \(t'\) where \(t < t'\).
It must contain a start and an end moment, along with the traffic light value to display on all roads of the intersection.


\subsubsection{Precedence Rules}
\label{\detokenize{taxonomy_serialization:precedence-rules}}\begin{quote}

Earliest {\hyperref[\detokenize{taxonomy_serialization:traffic-light-phase}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Phase}}}} first.
\end{quote}

In other words, if two or more {\hyperref[\detokenize{taxonomy_serialization:traffic-light-phase}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Phase}}}}s overlap, the traffic light phase starting the earliest has precedence over the others.

\begin{sphinxadmonition}{note}{Note:}
The rationale behind using earliest TL phase before is that it gives stronger assurances that everyone in the system will display the same information, even those that are experiencing heavy delays.

It also does not prevent overwriting TL phase.
One simply need to send TL phase starting very early in time (at the UNIX epoch for example) in order to override ‚Äúnormal‚Äù TL phases.
\end{sphinxadmonition}


\subsubsection{Schema}
\label{\detokenize{taxonomy_serialization:schema}}\begin{description}
\item[{\sphinxcode{\sphinxupquote{trafficLightPhaseId}}}] \leavevmode
The unique {\hyperref[\detokenize{taxonomy_serialization:identifier}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers}}}} of the TL phase.

\item[{\sphinxcode{\sphinxupquote{startMoment}}}] \leavevmode
The moment at which the TL phase starts (inclusive).

\item[{\sphinxcode{\sphinxupquote{endMoment}}}] \leavevmode
The moment at which the TL phase ends (exclusive).

\item[{\sphinxcode{\sphinxupquote{trafficLights}}}] \leavevmode
A mapping from road {\hyperref[\detokenize{taxonomy_serialization:identifier}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers}}}} to {\hyperref[\detokenize{taxonomy_serialization:traffic-light-value}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Value}}}}.

\end{description}


\subsection{Contract}
\label{\detokenize{taxonomy_serialization:contract}}\label{\detokenize{taxonomy_serialization:id13}}
A contract is an abstraction that fully defines the behavior of the traffic light for a given intersection from a time \(t\) to a time \(t'\) where \(t < t'\).


\subsubsection{Schema}
\label{\detokenize{taxonomy_serialization:id14}}\begin{description}
\item[{\sphinxcode{\sphinxupquote{contractId}}}] \leavevmode
The contract‚Äôs unique {\hyperref[\detokenize{taxonomy_serialization:identifier}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers}}}}.

\item[{\sphinxcode{\sphinxupquote{intersectionId}}}] \leavevmode
The {\hyperref[\detokenize{taxonomy_serialization:identifier}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers}}}} of the intersection for which this contract was concluded.

\item[{\sphinxcode{\sphinxupquote{trafficLightPhases}}}] \leavevmode
An array of {\hyperref[\detokenize{taxonomy_serialization:traffic-light-phase}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Phase}}}}s.

\end{description}


\chapter{Building a Microservice}
\label{\detokenize{building_a_microservice:building-a-microservice}}\label{\detokenize{building_a_microservice::doc}}

\section{Language Specifics}
\label{\detokenize{building_a_microservice:language-specifics}}

\subsection{Java / Scala}
\label{\detokenize{building_a_microservice:java-scala}}
\sphinxstylestrong{Prefered building system} Gradle

\sphinxstylestrong{Group ID} \sphinxcode{\sphinxupquote{com.vtl.greengo}}

\sphinxstylestrong{Artefact ID} \sphinxcode{\sphinxupquote{\textless{}service name\textgreater{}}}

\sphinxstylestrong{Main Class} \sphinxcode{\sphinxupquote{com.vtl.greengo.\textless{}service name\textgreater{}.Main}}

A private maven repository was created for the Greengo project.
If you want to import Greengo code or if you want to deploy some code for Greengo, have a look at the {\hyperref[\detokenize{private_maven_repo:private-maven-repo}]{\sphinxcrossref{\DUrole{std,std-ref}{Private Maven Repo}}}} documentation.


\section{Documenting a Service}
\label{\detokenize{building_a_microservice:documenting-a-service}}\label{\detokenize{building_a_microservice:service-documentation}}
All services should be documented.
Typically, a single service will have two documentations:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{general}: High-level overview of what the service does and how it is implemented. Available in the Greengo main documentation.

\item {} 
\sphinxstyleemphasis{code}: Low-level documentation, lists available classes and packages, function interfaces, etc. Available inside a \sphinxcode{\sphinxupquote{docs/}} folder in the microservice‚Äôs repository.

\end{itemize}


\subsection{\sphinxstyleemphasis{General} Documentation}
\label{\detokenize{building_a_microservice:general-documentation}}
To start the \sphinxstyleemphasis{general} documentation for a new micro-service, do the following:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Create a new folder \sphinxcode{\sphinxupquote{microservice\_\textless{}microservice name\textgreater{}}} at the root of the repository.

\item {} 
Create one or multiple \sphinxcode{\sphinxupquote{.rst}} files that document you microservice inside the newly created folder.
If you want to create multiple files, look at section {\hyperref[\detokenize{building_a_microservice:multiple-files-in-microservice-documentation}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiple Files in a Microservice Documentation}}}}.

\item {} 
Add the path of the root documentation file of your microservice at the bottom of the \sphinxcode{\sphinxupquote{toctree}} directive in the \sphinxcode{\sphinxupquote{index.rst}} file.

\end{enumerate}


\subsubsection{Multiple Files in a Microservice Documentation}
\label{\detokenize{building_a_microservice:multiple-files-in-a-microservice-documentation}}\label{\detokenize{building_a_microservice:multiple-files-in-microservice-documentation}}
All microservice documentation must have a root file that includes the other ones.

Create a root file named \sphinxcode{\sphinxupquote{index.rst}} containing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gh}{\PYGZlt{}Microservice Name\PYGZgt{}}
\PYG{g+gh}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{p}{..} \PYG{o+ow}{toctree}\PYG{p}{::}
  \PYG{n+nc}{:maxdepth:} \PYG{n+nf}{2}
  \PYG{n+nc}{:caption:} \PYG{n+nf}{Contents:}

  \PYGZlt{}other\PYGZus{}file\PYGZus{}in\PYGZus{}microservice\PYGZus{}documentation\PYGZgt{}
\end{sphinxVerbatim}

You can then create other files in the folder of the microservice‚Äôs documentation and reference them in the \sphinxcode{\sphinxupquote{index.rst}} file.


\subsection{\sphinxstyleemphasis{Code} Documentation}
\label{\detokenize{building_a_microservice:code-documentation}}
The \sphinxstyleemphasis{code} documentation must be placed inside the repository of the microservice inside a \sphinxcode{\sphinxupquote{docs/}} folder located at the root of the service‚Äôs repository.

As each language generally have its own way of documenting code, this documentation does not prescribe any specific way.


\subsection{READMEs}
\label{\detokenize{building_a_microservice:readmes}}
To make it easy to find the appropriate documentation, microservices‚Äô READMEs should contain the following text where you replace \sphinxcode{\sphinxupquote{\textless{}microservice\_folder\_name\textgreater{}}} with the name of your microservice‚Äôs folder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gu}{\PYGZsh{}\PYGZsh{}} Documentation

\PYG{g+gu}{\PYGZsh{}\PYGZsh{}\PYGZsh{}} General Documentation

Some high\PYGZhy{}level documentation can be found [\PYG{n+nt}{here}](\PYG{n+na}{https://greengo\PYGZhy{}documentation.appspot.com/\PYGZlt{}microservice\PYGZus{}folder\PYGZus{}name\PYGZgt{}/index.html}).

\PYG{g+gu}{\PYGZsh{}\PYGZsh{}\PYGZsh{}} Code Documentation

Documentation for the code can be found in the [\PYG{n+nt}{docs/}](\PYG{n+na}{./docs/}) folder.
\end{sphinxVerbatim}


\chapter{Deployments}
\label{\detokenize{deployments:deployments}}\label{\detokenize{deployments::doc}}
Deployments for Greengo are managed by the \sphinxstylestrong{Kubernetes} framework.
This implies that all microservices need to be containerized using \sphinxstylestrong{Docker}.

Each microservice defines and manages its own Kubernetes resources (deployments, pods, services, secrets, configmaps, etc).
Each microservice should further provide documentation as to how it is deployed and how to manage the said deployment.

The convention is to put all Kubernetes related files into a \sphinxcode{\sphinxupquote{kubernetes/}} folder at the root of the microservice repository.
Regarding Docker-related files, the convention is to put them in a \sphinxcode{\sphinxupquote{docker/}} folder, also at the root of the microservice repo.
Finally the documentation that concerns itself with deployment should appear in each microservice documentation as a root level document in the doc bearing the name ‚ÄúDeployment‚Äù.


\section{Local Deployments}
\label{\detokenize{deployments:local-deployments}}
Even though each microservice handles its deployment autonomously from the others, it is useful to be able to deploy a full instance of Greengo on a local machine for testing and debugging purposes.

This section describes the procedure to do so.


\subsection{Introduction}
\label{\detokenize{deployments:introduction}}
A local deployment of Greengo allows you to run a full greengo instance on your local machine.


\subsection{Prerequisites}
\label{\detokenize{deployments:prerequisites}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gcloud}} needs to be installed and setup.
It provides a way to connect to Google Cloud.

\item {} 
\sphinxcode{\sphinxupquote{docker}} needs to be installed.
It handles building the microservice image to test locally.

\item {} 
\sphinxcode{\sphinxupquote{kubectl}} needs to be installed.
It is the command line tool to interact with your Kubernetes cluster.

\item {} 
\sphinxcode{\sphinxupquote{minikube}} needs to be installed.
It starts a Kubernetes cluster on your local machine and emulates a hypervisors for the pods.
You will also want to setup the correct driver (see next bullet point).

\item {} 
VirtualBox or KVM2 needs to be installed.
Those are hypervisors and are needed by minikube to execute the pods.
Minikube calls them drivers.
The default driver is \sphinxcode{\sphinxupquote{virtualbox}}.
The default driver can be set using \sphinxcode{\sphinxupquote{minikube config set driver \textless{}driver\_name\textgreater{}}}.

The \sphinxcode{\sphinxupquote{virtualbox}} driver is the oldest and most tested driver and your best bet on Windows and MacOS.
On Linux, you might want to have a look at KVM2 (Kernel-based Virtual Machine) for performance improvements.
Please note that installing KVM2 can be tricky (\sphinxhref{https://computingforgeeks.com/complete-installation-of-kvmqemu-and-virt-manager-on-arch-linux-and-manjaro/}{Tutorial on installing KVM2 on Arch Linux}).
If you want an easy solution, go for the \sphinxcode{\sphinxupquote{virtualbox}} driver.

\end{itemize}


\subsection{Running a Local Instance of Greengo}
\label{\detokenize{deployments:running-a-local-instance-of-greengo}}

\subsubsection{Using the Provided Script}
\label{\detokenize{deployments:using-the-provided-script}}
Use the script \sphinxcode{\sphinxupquote{local\_deployment.py}} in the \sphinxcode{\sphinxupquote{local/}} folder.
It will automatically deploy a whole Greengo instance.

You can print the script‚Äôs documentation using \sphinxcode{\sphinxupquote{./local\_deployment.py -{-}help}}.


\subsubsection{Manually Starting Everything}
\label{\detokenize{deployments:manually-starting-everything}}
If you prefer to start the cluster manually, follow the instructions hereafter.


\paragraph{Start Minikube}
\label{\detokenize{deployments:start-minikube}}
Start a minikube instance using \sphinxcode{\sphinxupquote{minikube start}}.
Minikube makes it possible to have a full Kubernetes cluster running on a single node: your local machine.


\paragraph{Configure Minikube‚Äôs Docker Deamon to Download from GCR}
\label{\detokenize{deployments:configure-minikube-s-docker-deamon-to-download-from-gcr}}
Configure the docker deamon used by \sphinxcode{\sphinxupquote{minikube}} to use the \sphinxcode{\sphinxupquote{container-registry-read-only}} service account:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
kubectl create secret docker\PYGZhy{}registry gcr\PYGZhy{}json\PYGZhy{}key \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}docker\PYGZhy{}server\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}https://gcr.io\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}docker\PYGZhy{}username\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZus{}json\PYGZus{}key\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}docker\PYGZhy{}password\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{\PYGZdl{}(}cat ./credentials/gcr\PYGZhy{}read\PYGZhy{}only.json\PYG{k}{)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}docker\PYGZhy{}email\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}not@valid.id\PYGZdq{}}
\end{sphinxVerbatim}


\paragraph{Start All Microservices Except the Tested One (If Any)}
\label{\detokenize{deployments:start-all-microservices-except-the-tested-one-if-any}}
Start all the other required pods using the templates provided in the \sphinxcode{\sphinxupquote{deploy\_from\_gcr}} folder with commands along the line of \sphinxcode{\sphinxupquote{kubectl apply -f deploy\_from\_gcr/{[}microservice\_to\_deploy{]}}}.


\subsubsection{Use the Same Docker Deamon as Minikube}
\label{\detokenize{deployments:use-the-same-docker-deamon-as-minikube}}\label{\detokenize{deployments:configure-docker-with-minikube}}
The easiest way to test a given microservice is to build its docker container on your local machine using the same docker deamon as the one \sphinxcode{\sphinxupquote{minikube}} uses.
Otherwise, you will need to deploy the microservice to some online docker registry and \sphinxcode{\sphinxupquote{minikube}} will then download it when you start the pod.

Configure your terminal to use the same docker deamon as \sphinxcode{\sphinxupquote{minikube}} with \sphinxcode{\sphinxupquote{eval \$(minikube docker-env)}}.
you need to repeat this command in each terminal in which you want to use \sphinxcode{\sphinxupquote{minikube}}‚Äôs docker deamon instead of your local machine‚Äôs one.
Further, the changes are undone as soon as you close the terminal.


\subsubsection{Build and Start the Container of the Microservice to Test (If Any)}
\label{\detokenize{deployments:build-and-start-the-container-of-the-microservice-to-test-if-any}}
You will want to apply the instruction on how to {\hyperref[\detokenize{deployments:configure-docker-with-minikube}]{\sphinxcrossref{\DUrole{std,std-ref}{Use the Same Docker Deamon as Minikube}}}} first.

Build the container of the microservice you want to test normally.
This will probably be some command along the lines of \sphinxcode{\sphinxupquote{docker build -t {[}container\_name{]} -f {[}path\_to\_docker\_file{]} .}}.
See the microservice‚Äôs documentation for details on this step.
You can check that the container was built using \sphinxcode{\sphinxupquote{docker image list}}.

Now run your microservice using \sphinxcode{\sphinxupquote{kubectl run {[}microservice\_name{]} -{-}image={[}container\_name{]}:{[}tag{]} -{-}image-pull-policy=Never}}.

Alternatively, you can create a deployment file for your microservice using the following template:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{apiVersion}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{apps/v1}
\PYG{n+nt}{kind}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{Deployment}
\PYG{c+c1}{\PYGZsh{} Deployment metadata}
\PYG{n+nt}{metadata}\PYG{p}{:}
  \PYG{n+nt}{name}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}deployment}
  \PYG{n+nt}{labels}\PYG{p}{:}
    \PYG{n+nt}{app}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}
    \PYG{n+nt}{environment}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{local}
\PYG{n+nt}{spec}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Contains the specification of a pod}
  \PYG{n+nt}{replicas}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
  \PYG{n+nt}{selector}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Specifies labels that pods need to match to be managed by this deployment}
    \PYG{n+nt}{matchLabels}\PYG{p}{:}
      \PYG{n+nt}{app}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}
      \PYG{n+nt}{environment}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{local}
  \PYG{n+nt}{template}\PYG{p}{:}
    \PYG{n+nt}{metadata}\PYG{p}{:}
      \PYG{n+nt}{labels}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Pods labels}
        \PYG{n+nt}{app}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}
        \PYG{n+nt}{environment}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{local}
    \PYG{n+nt}{spec}\PYG{p}{:}
      \PYG{n+nt}{containers}\PYG{p}{:}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{name}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}
        \PYG{n+nt}{image}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{n+nv}{microservice}\PYG{p+pIndicator}{]}\PYG{l+lScalar+lScalarPlain}{:latest}
        \PYG{n+nt}{imagePullPolicy}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{Never}
\end{sphinxVerbatim}

Where you replace \sphinxcode{\sphinxupquote{{[}microservice{]}}} with the name of your docker container.
Then apply the depoyment with \sphinxcode{\sphinxupquote{kubectl apply -f {[}deployment\_file\_name{]}}}.

Note that you must set \sphinxcode{\sphinxupquote{spec.template.spec.containers.imagePullPolicy}} to \sphinxcode{\sphinxupquote{Never}}.
Otherwise minikube will try to download a newer version of the image from the default Docker registry.


\subsection{Updating Running Pods}
\label{\detokenize{deployments:updating-running-pods}}
Use \sphinxcode{\sphinxupquote{kubectl replace -{-}force -f {[}path\_to\_deployment\_file{]}}} to force update a pod.
This will cause a service outage.


\subsection{Cleaning Up}
\label{\detokenize{deployments:cleaning-up}}
Delete the Kubernetes deployments using \sphinxcode{\sphinxupquote{kubectl delete {[}thing\_to\_delete{]}}}.

Delete the minikube cluster using \sphinxcode{\sphinxupquote{minikube delete}}.


\chapter{PubSub}
\label{\detokenize{pubsub:pubsub}}\label{\detokenize{pubsub::doc}}
PubSub is used to communicate between all microservices of Greengo.

This pages documents the following aspects of each topics:
\begin{itemize}
\item {} 
What is the semantic content of a topic?

\item {} 
How is a topic sharded?

\end{itemize}


\section{Message Serialization}
\label{\detokenize{pubsub:message-serialization}}
Messages sent on PubSub topics are serialized using Google \sphinxstylestrong{Protocol Buffer}.
The schemas of the messages for each topics can be found inside the \sphinxcode{\sphinxupquote{greengo\_serialization}} repository (look at \sphinxcode{\sphinxupquote{src/main/proto/topics/}}).
Java and Scala packages containing code to (de)serialize protocol buffer messages can be found inside Greengo‚Äôs {\hyperref[\detokenize{private_maven_repo:private-maven-repo}]{\sphinxcrossref{\DUrole{std,std-ref}{Private Maven Repo}}}}.


\section{\sphinxstyleliteralintitle{\sphinxupquote{vehicle-positions}}}
\label{\detokenize{pubsub:vehicle-positions}}
Vehicles must send their positions to the Greengo system.
They do it on the \sphinxcode{\sphinxupquote{vehicle-positions-\textless{}index\textgreater{}}} family of topics, where index is the index of the region the vehicle is in (which can be computed using the vehicle‚Äôs position).


\subsection{Computing the Index}
\label{\detokenize{pubsub:computing-the-index}}
The following Python pseudo code allows to compute the index of the \sphinxcode{\sphinxupquote{vehicle-positions}} topic on which to send the position of a given vehicle.

\sphinxcode{\sphinxupquote{\textless{}index\textgreater{}}} is a string of the form \sphinxcode{\sphinxupquote{\textless{}lat\textgreater{}-\textless{}lon\textgreater{}}} where \sphinxcode{\sphinxupquote{\textless{}lat\textgreater{}}} and \sphinxcode{\sphinxupquote{\textless{}lon\textgreater{}}} are integers converted to strings that represent the geographical zone in which the vehicle is located.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{regions\PYGZus{}per\PYGZus{}latitude\PYGZus{}degree} \PYG{o}{=} \PYG{n}{regions\PYGZus{}per\PYGZus{}longitude\PYGZus{}degree} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}topic\PYGZus{}index}\PYG{p}{(}\PYG{n}{vehicle}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
    \PYG{n}{latitude\PYGZus{}index}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{regions\PYGZus{}per\PYGZus{}latitude\PYGZus{}degree} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{90.0} \PYG{o}{+} \PYG{n}{vehicle}\PYG{o}{.}\PYG{n}{latitude}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{longitude\PYGZus{}index}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{regions\PYGZus{}per\PYGZus{}longitude\PYGZus{}degree} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{180.0} \PYG{o}{+} \PYG{n}{vehicle}\PYG{o}{.}\PYG{n}{longitude}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{latitude\PYGZus{}index}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{longitude\PYGZus{}index}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}topic\PYGZus{}name}\PYG{p}{(}\PYG{n}{vehicle}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vehicle\PYGZhy{}positions\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{compute\PYGZus{}topic\PYGZus{}index}\PYG{p}{(}\PYG{n}{vehicle}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Message Content}
\label{\detokenize{pubsub:message-content}}
The content of a record on a topic from the \sphinxcode{\sphinxupquote{vehicle-positions-\textless{}index\textgreater{}}} family of topics is defined by the corresponding protocol buffer files found in the \sphinxcode{\sphinxupquote{greengo\_serialization}} git repo.


\section{\sphinxstyleliteralintitle{\sphinxupquote{vehicle-localization}}}
\label{\detokenize{pubsub:vehicle-localization}}
One topic that contains the localization messages for all vehicle.


\subsection{Message Content}
\label{\detokenize{pubsub:id1}}
The content of a record on this topic is defined by the corresponding protocol buffer in the \sphinxcode{\sphinxupquote{greengo\_serialization}} repo.


\chapter{Private Maven Repo}
\label{\detokenize{private_maven_repo:private-maven-repo}}\label{\detokenize{private_maven_repo:id1}}\label{\detokenize{private_maven_repo::doc}}
Greengo has its own private maven repository hosted on GCP.
This repo is used to store artifacts that are useful for multiple Greengo microservices.

The repo is available here: \sphinxurl{https://greengo-private-maven-repo.appspot.com}.


\section{Read}
\label{\detokenize{private_maven_repo:read}}
Fetching packages can be done by adding the following repository to the list of gradle reposotiries inside \sphinxcode{\sphinxupquote{build.gradle}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ext} \PYG{p}{\PYGZob{}}
   \PYG{n}{privateMavenRepoPassword} \PYG{o}{=} \PYG{n}{System}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}USER\PYGZus{}PASSWORD}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{privateMavenRepoPassword} \PYG{o}{==} \PYG{n}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{privateMavenRepoPassword} \PYG{o}{=} \PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}USER\PYGZus{}PASSWORD}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{repositories} \PYG{p}{\PYGZob{}}
   \PYG{n}{maven} \PYG{p}{\PYGZob{}}
      \PYG{n}{credentials} \PYG{p}{\PYGZob{}}
            \PYG{n}{username} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{user}\PYG{l+s+s1}{\PYGZsq{}}
            \PYG{n}{password} \PYG{n}{privateMavenRepoPassword}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{url} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://greengo\PYGZhy{}private\PYGZhy{}maven\PYGZhy{}repo.appspot.com}\PYG{l+s+s2}{\PYGZdq{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Please also read how to {\hyperref[\detokenize{private_maven_repo:storing-passwords}]{\sphinxcrossref{\DUrole{std,std-ref}{Store the Passwords}}}}.


\section{Write}
\label{\detokenize{private_maven_repo:write}}
It is recommended to use the following configuration to be able to both read and write to the private maven repo (or just wrtie):

\sphinxcode{\sphinxupquote{build.gradle}}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apply} \PYG{n}{plugin}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{java}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{apply} \PYG{n}{plugin}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{maven}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{ext} \PYG{p}{\PYGZob{}}
   \PYG{n}{privateMavenRepoPassword} \PYG{o}{=} \PYG{n}{System}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}ADMIN\PYGZus{}PASSWORD}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{privateMavenRepoPassword} \PYG{o}{==} \PYG{n}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{privateMavenRepoPassword} \PYG{o}{=} \PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}ADMIN\PYGZus{}PASSWORD}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{group} \PYG{o}{=} \PYG{n}{ARTIFACT\PYGZus{}PACKAGE}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{project}\PYG{o}{.}\PYG{n}{hasProperty}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{releaseversion}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{version} \PYG{o}{=} \PYG{n}{releaseversion}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
   \PYG{n}{version} \PYG{o}{=} \PYG{n}{ARTIFACT\PYGZus{}VERSION}
\PYG{p}{\PYGZcb{}}

\PYG{n}{uploadArchives} \PYG{p}{\PYGZob{}}
   \PYG{n}{repositories} \PYG{p}{\PYGZob{}}
      \PYG{n}{mavenDeployer} \PYG{p}{\PYGZob{}}
         \PYG{n}{repository}\PYG{p}{(}\PYG{n}{url}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://greengo\PYGZhy{}private\PYGZhy{}maven\PYGZhy{}repo.appspot.com}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{authentication}\PYG{p}{(}
               \PYG{n}{userName}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{admin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
               \PYG{n}{password}\PYG{p}{:} \PYG{n}{privateMavenRepoPassword}
            \PYG{p}{)}
         \PYG{p}{\PYGZcb{}}
         \PYG{n}{pom}\PYG{o}{.}\PYG{n}{version} \PYG{o}{=} \PYG{n}{version}
         \PYG{n}{pom}\PYG{o}{.}\PYG{n}{artifactId} \PYG{o}{=} \PYG{n}{ARTIFACT\PYGZus{}NAME}
         \PYG{n}{pom}\PYG{o}{.}\PYG{n}{groupId} \PYG{o}{=} \PYG{n}{ARTIFACT\PYGZus{}PACKAGE}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\sphinxcode{\sphinxupquote{gradle.properties}}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ARTIFACT\PYGZus{}VERSION}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{version}\PYG{o}{\PYGZgt{}}
\PYG{n}{ARTIFACT\PYGZus{}NAME}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{n}{ARTIFACT\PYGZus{}PACKAGE}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{package}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\end{quote}


\subsection{Using a Pipeline on BitBucket}
\label{\detokenize{private_maven_repo:using-a-pipeline-on-bitbucket}}
If you want to build artifacts and autodeploy them to the private Maven repo using Bitbucket Pipelines, you can use the following pipeline.

\sphinxcode{\sphinxupquote{bitbucket-pipelines.yaml}}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{definitions}\PYG{p}{:}
  \PYG{n+nt}{steps}\PYG{p}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nl}{\PYGZam{}compile\PYGZhy{}jar}
        \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{Compile}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{jar}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{binary}
        \PYG{n+nt}{image}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{openjdk:8}
        \PYG{n+nt}{caches}\PYG{p}{:}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{gradle}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{docker}
        \PYG{n+nt}{script}\PYG{p}{:}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{export}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{TAG=\PYGZdl{}(echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}BITBUCKET\PYGZus{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\textbar{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{sed}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}e}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}s/v//g\PYGZdq{})}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{export}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{SUFFIX=\PYGZdl{}([[}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{!}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}z}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{]]}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZam{}\PYGZam{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\textbar{}\textbar{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}snapshot\PYGZdq{})}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{bash}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./gradlew}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{jar}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}Preleaseversion=\PYGZdq{}\PYGZdl{}SUFFIX\PYGZdq{}}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nl}{\PYGZam{}upload\PYGZhy{}jar}
        \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{Upload}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{jar}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{binary}
        \PYG{n+nt}{image}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{openjdk:8}
        \PYG{n+nt}{caches}\PYG{p}{:}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{gradle}
        \PYG{n+nt}{script}\PYG{p}{:}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{export}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{TAG=\PYGZdl{}(echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}BITBUCKET\PYGZus{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\textbar{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{sed}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}e}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}s/v//g\PYGZdq{})}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{export}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{SUFFIX=\PYGZdl{}([[}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{!}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}z}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{]]}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZam{}\PYGZam{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZdl{}TAG\PYGZdq{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\textbar{}\textbar{}}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{echo}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}snapshot\PYGZdq{})}
          \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{bash}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./gradlew}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{uploadArchives}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}Preleaseversion=\PYGZdq{}\PYGZdl{}SUFFIX\PYGZdq{}}

\PYG{n+nt}{pipelines}\PYG{p}{:}
  \PYG{n+nt}{tags}\PYG{p}{:}
    \PYG{n+nt}{v*}\PYG{p}{:}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nv}{*compile\PYGZhy{}jar}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nv}{*upload\PYGZhy{}jar}

  \PYG{n+nt}{branches}\PYG{p}{:}
    \PYG{n+nt}{\PYGZsq{}**\PYGZsq{}}\PYG{p}{:}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nv}{*compile\PYGZhy{}jar}
    \PYG{n+nt}{master}\PYG{p}{:}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{step}\PYG{p}{:} \PYG{n+nv}{*upload\PYGZhy{}jar}
\end{sphinxVerbatim}
\end{quote}

The above pipeline will automatically compile the code into a JAR when pushing on any branch, thus giving feedback on whether the code is passing.
It will further deploy the code on the private Maven repo when committing on master or then tagging the branch using a tag of the form \sphinxcode{\sphinxupquote{v\textless{}major\textgreater{}.\textless{}minor\textgreater{}.\textless{}patch\textgreater{}}} (see {\hyperref[\detokenize{software_engineering:semantic-versioning}]{\sphinxcrossref{\DUrole{std,std-ref}{Semantic Versioning}}}} for details on this versioning convention) in an artifact with version equal to \sphinxcode{\sphinxupquote{\textless{}major\textgreater{}.\textless{}minor\textgreater{}.\textless{}patch\textgreater{}}} if the branch was tagged or equal to \sphinxcode{\sphinxupquote{snapshot}} otherwise.


\section{Store the Passwords}
\label{\detokenize{private_maven_repo:store-the-passwords}}\label{\detokenize{private_maven_repo:storing-passwords}}
There are two recommended ways to store the passwords needed to use the private maven repo:
\begin{itemize}
\item {} 
Have environment variables named \sphinxcode{\sphinxupquote{GREENGO\_PRIVATE\_MAVEN\_REPO\_USER\_PASSWORD}} and/or \sphinxcode{\sphinxupquote{GREENGO\_PRIVATE\_MAVEN\_REPO\_ADMIN\_PASSWORD}} containing the corresponding password.

\item {} 
Define the passwords as global Gradle variables in \sphinxcode{\sphinxupquote{\textasciitilde{}/.gradle/gradle.properties}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}ADMIN\PYGZus{}PASSWORD}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{admin} \PYG{n}{password}\PYG{o}{\PYGZgt{}}
\PYG{n}{GREENGO\PYGZus{}PRIVATE\PYGZus{}MAVEN\PYGZus{}REPO\PYGZus{}USER\PYGZus{}PASSWORD}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{user} \PYG{n}{password}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Where you replace \sphinxcode{\sphinxupquote{\textless{}admin password\textgreater{}}} and \sphinxcode{\sphinxupquote{\textless{}user password\textgreater{}}} with the correct password that can be found in the \sphinxcode{\sphinxupquote{src/main/webapp/WEB-INF/users.txt}} file in the \sphinxcode{\sphinxupquote{greengo\_private\_maven\_repo}} BitBucket repository.

\end{itemize}


\subsection{When to Use Which Approach}
\label{\detokenize{private_maven_repo:when-to-use-which-approach}}\begin{itemize}
\item {} 
The environment variable is the recommended approach on BitBucket.

\item {} 
The password file is recommended on local computers.

\end{itemize}


\subsection{BitBucket Pipelines}
\label{\detokenize{private_maven_repo:bitbucket-pipelines}}
To define an environment variable on BitBucket that can be used during pipelines, go to the repo Settings then to the ‚ÄúPipelines/Repository Variable‚Äù tab and create the variable there.


\section{GCP Hosting}
\label{\detokenize{private_maven_repo:gcp-hosting}}
The private maven repository is hosted on the GCP project \sphinxcode{\sphinxupquote{greengo-private-maven-repo}}.
A simple website is deployed on App Engine that serves the artifacts stored in a Google Storage Bucket.
The server is protected with simple web credentials.
The BitBucket repo \sphinxcode{\sphinxupquote{greengo\_private\_maven\_repo}} that contains the code for the private Maven repo is automatically deployed on GCP when committing on master.


\chapter{Design}
\label{\detokenize{design:design}}\label{\detokenize{design::doc}}
This page lists the design conventions used for the Greengo project.


\section{Fonts}
\label{\detokenize{design/fonts:fonts}}\label{\detokenize{design/fonts::doc}}
Greengo makes usage of two fonts:
\begin{itemize}
\item {} 
MADE Evolve Sans EVO for titles, logos and other emphasized elements.

\item {} 
Roboto Slab for text.

\end{itemize}


\subsection{MADE Evolve Sans EVO}
\label{\detokenize{design/fonts:made-evolve-sans-evo}}
Used for titles, logos, and other emphasized elements.

The font MADE Evolve Sans comes in two variants: normal and EVO.
The capitals of the EVO variant have a distinctive futuristic look.
The lower case letters are identical in both variants.
The EVO variant should be used everywhere.

The font is available in different weights:
\begin{itemize}
\item {} 
Bold

\item {} 
Medium

\item {} 
Regular

\item {} 
Light

\item {} 
Thin

\end{itemize}

For really big titles, it is recommended to use the light or thin font.
For sectioning or emphasized texts regular, medium and bold weight are recommended.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{made_evolve_sans_evo_thin_sample}.png}
\end{figure}


\subsection{Roboto Slab}
\label{\detokenize{design/fonts:roboto-slab}}
Used for text.

The font is available in different weights:
\begin{itemize}
\item {} 
Black

\item {} 
Extra Bold

\item {} 
Bold

\item {} 
Semi Bold

\item {} 
Medium

\item {} 
Regular

\item {} 
Light

\item {} 
Extra Light

\item {} 
Thin

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{roboto_slab_sample}.png}
\end{figure}


\subsection{Source Code Pro}
\label{\detokenize{design/fonts:source-code-pro}}
Monospaced fonts are used for displaying code.

Greengo products use \sphinxstylestrong{Source Code Pro} as their monospaced font.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{source_code_pro_sample}.png}
\end{figure}




\section{Colors}
\label{\detokenize{design/colors:colors}}\label{\detokenize{design/colors::doc}}
A preview of the colors below can be obtained using \sphinxhref{https://material.io/tools/color/\#!/?view.left=0\&view.right=1\&primary.color=13ef80\&secondary.color=c442ff}{a material.io tool}.
\begin{description}
\item[{Primary}] \leavevmode
Used for branding and successes.

\sphinxstyleemphasis{\#Emerald}

Primary

Hex: \sphinxcode{\sphinxupquote{\#13ef80}}

RGB: \sphinxcode{\sphinxupquote{rgb(19, 239, 128)}}

\sphinxstyleemphasis{\#Lime Soap}

Primary Light

Hex: \sphinxcode{\sphinxupquote{\#6bffb1}}

RGB: \sphinxcode{\sphinxupquote{rgb(107, 255, 177)}}

\sphinxstyleemphasis{\#Lush Forest}

Primary Dark

Hex: \sphinxcode{\sphinxupquote{\#00bb51}}

RGB: \sphinxcode{\sphinxupquote{rgb(0, 187, 81)}}

\item[{Alternate Primary}] \leavevmode
Used for gradients with the primary color.

\sphinxstyleemphasis{\#Wild Caribbean Green}

Primary Alternate

Hex: \sphinxcode{\sphinxupquote{\#1dd1a1}}

RGB: \sphinxcode{\sphinxupquote{rgb(29, 209, 161)}}

\item[{Secondary}] \leavevmode
\sphinxstyleemphasis{\#Amethyst}

Secondary

Hex: \sphinxcode{\sphinxupquote{\#c442ff}}

RGB: \sphinxcode{\sphinxupquote{rgb(196, 66, 255)}}

Lotus Pink

Secondary Light

Hex: \sphinxcode{\sphinxupquote{\#fb78ff}}

RGB: \sphinxcode{\sphinxupquote{rgb(251, 120, 255)}}

Deep Purple

Secondary Dark

Hex: \sphinxcode{\sphinxupquote{\#8e00cb}}

RGB: \sphinxcode{\sphinxupquote{rgb(142, 0, 203)}}

\item[{Yellow}] \leavevmode
Used for warnings.

\sphinxstyleemphasis{\#Sun Flower}

Yellow

Hex: \sphinxcode{\sphinxupquote{\#ffe44a}}

RGB: \sphinxcode{\sphinxupquote{rgb(255, 228, 74)}}

\item[{Orange}] \leavevmode
\sphinxstyleemphasis{\#Double Dragon Skin}

Orange

Hex: \sphinxcode{\sphinxupquote{\#ff9f43}}

RGB: \sphinxcode{\sphinxupquote{rgb(255, 159, 67)}}

\item[{Red}] \leavevmode
Used for errors.

\sphinxstyleemphasis{\#Watermelon}

Red

Hex: \sphinxcode{\sphinxupquote{\#ff4757}}

RGB: \sphinxcode{\sphinxupquote{rgb(255, 71, 87)}}

\item[{Blue}] \leavevmode
Used for information.

\sphinxstyleemphasis{\#Clear Chill}

Blue

Hex: \sphinxcode{\sphinxupquote{\#52a4f7}}

RGB: \sphinxcode{\sphinxupquote{rgb(77, 155, 232)}}

\end{description}


\section{Design Assets}
\label{\detokenize{design/design_assets:design-assets}}\label{\detokenize{design/design_assets::doc}}

\subsection{Branding Items}
\label{\detokenize{design/design_assets:branding-items}}
Design assests currently include the following images related to Greengo:
\begin{description}
\item[{Heading}] \leavevmode
The word ‚ÄúGreengo‚Äù, typeset with Greengo‚Äôs style

\item[{Logo}] \leavevmode
Greengo‚Äôs Logo

\item[{Banner}] \leavevmode
Combination of Logo and Heading, or specially designed heading.

\end{description}


\subsection{LoD}
\label{\detokenize{design/design_assets:lod}}
Depending on the space an item is displayed in, a different level of details (LoD) must be used.
Bigger images call for more details, smaller images must be simpler.
This makes for a better UI and UX.


\subsection{Size}
\label{\detokenize{design/design_assets:size}}
The size of a branding item is its width in centimeters and its height in centimeters.


\subsection{Resolution}
\label{\detokenize{design/design_assets:resolution}}
The resolution of an image is the number of pixel per unit of length, generally given in pixel per inch (ppi).

The web is a lot about speed and using images of lesser quality allows to increase the delivery speed.

\begin{sphinxadmonition}{warning}{Warning:}
Be mindful that responsive layouts might scale images up. Try to keep the resolution at a minimum of 100ppi in all cases.
\end{sphinxadmonition}


\subsection{Logo}
\label{\detokenize{design/design_assets:logo}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{671fa7bff117c4e4c7ea601516a995652e3ef328}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{ca4b7f84524a7e5cd70510d785382f1150b6d33d}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{logo-black-on-white-high-400}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{logo-white-on-black-high-400}.png}
\end{figure}


\subsubsection{Formats}
\label{\detokenize{design/design_assets:formats}}
The logo‚Äôs sources are SVG files.

When using the logo, you can include either the minified SVG files or generated PNG images.
If possible, prefer the minified SVG files as they are vector formats (lighter and lossless when zooming).


\subsection{Heading}
\label{\detokenize{design/design_assets:heading}}
The following headings are valid.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{8a46ead0e1fa69283a7962e761ad151f1e609711}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{10ac69c3fb27913dcfee125b53985708f8f0d862}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{02e4c585a78e49c2d32640e0d66c1649aa565211}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{b62436dd4b70e0e8f1b787bcf87f50bf548b087f}.png}
\end{figure}


\subsubsection{LoD}
\label{\detokenize{design/design_assets:id1}}
Available in \sphinxstyleemphasis{high} and \sphinxstyleemphasis{low} level of details.


\subsection{Banners}
\label{\detokenize{design/design_assets:banners}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{b1bb11c81bf0d50957b9e35d9ba8c5e0884016d5}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{1ef8b4b10f38eb6729ecb3f2a382749528e6aead}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{ad950c992fbc62a8a41876386f682d47af39c8c9}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{d21600b46f4d7f09f644c150132e9d870c1c1a58}.png}
\end{figure}


\subsubsection{LoD}
\label{\detokenize{design/design_assets:id2}}
Available in \sphinxstyleemphasis{high} and \sphinxstyleemphasis{low} level of details.


\section{Branding}
\label{\detokenize{design/branding:branding}}\label{\detokenize{design/branding::doc}}

\subsection{Mission Statement}
\label{\detokenize{design/branding:mission-statement}}
Save people‚Äôs time by providing smart transport infrastructure.


\subsection{In Three Words}
\label{\detokenize{design/branding:in-three-words}}\begin{itemize}
\item {} 
Smart

\item {} 
Future Proof

\item {} 
Efficient

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
Change the word ‚Äúefficient‚Äù to something else!
\end{sphinxadmonition}


\subsection{Slogan}
\label{\detokenize{design/branding:slogan}}
\begin{sphinxadmonition}{warning}{Warning:}
Yet to define!
\end{sphinxadmonition}


\section{Building the Design Repo}
\label{\detokenize{design/building:building-the-design-repo}}\label{\detokenize{design/building::doc}}
To build the whole design repository after making some changes to the source, move to the root folder and execute \sphinxcode{\sphinxupquote{make}}.


\chapter{Websites}
\label{\detokenize{websites/index:websites}}\label{\detokenize{websites/index::doc}}

\section{Greengo Websites}
\label{\detokenize{websites/greengo_websites:greengo-websites}}\label{\detokenize{websites/greengo_websites::doc}}

\subsection{Currently Deployed Websites}
\label{\detokenize{websites/greengo_websites:currently-deployed-websites}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{greengo\_sales}}: \sphinxhref{https://greengo.ai/}{greengo.ai} (and \sphinxhref{https://greengoai.com/}{greengoai.com} but \sphinxhref{https://greengo.ai/}{greengo.ai} is preferred)

\item {} 
\sphinxcode{\sphinxupquote{greengo\_documentation}}: \sphinxhref{https://greengo.dev/}{greengo.dev}

\end{itemize}


\subsection{DNS}
\label{\detokenize{websites/greengo_websites:dns}}

\subsubsection{As of 2020-03}
\label{\detokenize{websites/greengo_websites:as-of-2020-03}}
Managed by \sphinxhref{https://GoDaddy.com}{GoDaddy.com}:
\begin{itemize}
\item {} 
\sphinxhref{https://greengo.ai/}{greengo.ai}

\item {} 
\sphinxhref{https://greengoai.com/}{greengoai.com}

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
Some domains on GoDaddy were not bought by the Greengo account directly so the Greengo account has a delegated access to them.

Go to \sphinxcode{\sphinxupquote{Account Settings \textgreater{} Delegate Access}} to see these domain names.
\end{sphinxadmonition}

Managed by \sphinxhref{https://domains.google.com}{Google Domains}
\begin{itemize}
\item {} 
\sphinxhref{https://greengo.dev}{greengo.dev}

\end{itemize}


\subsection{Architectural Goal}
\label{\detokenize{websites/greengo_websites:architectural-goal}}
The architecture decided upon for greengo websites aims to ease the development of multiple websites with a consistent feel.
For this reason, the CSS code was extracted to a separate repository and should be used by all greengo websites.


\subsection{Technologies}
\label{\detokenize{websites/greengo_websites:technologies}}
The recommended technologies for Greengo websites are as follow:
\begin{itemize}
\item {} 
Web Framework: \sphinxhref{https://sapper.svelte.dev/}{Sapper}.
Sapper allows to make heavy code reuse.
The created websites are single page application which are much faster than traditional websites.
As Sapper precaches content, the website is actually lightning fast!
The first page accessed is server-side rendered, thus Sapper is also Search-Engine optimized.
Finally, Sapper is a JavaScript framework, thus removing the need to learn one more language to develop a website.

\item {} 
CSS framework: \sphinxhref{https://bulma.io/documentation/}{Bulma} from SASS.
Bulma is a CSS framework that aims to be lightweight and easily customizable.
It is also very simple.
We use the SASS CSS preprocessor so as to make development orders of magnitude easier.

\end{itemize}


\subsection{Including CSS in a Website}
\label{\detokenize{websites/greengo_websites:including-css-in-a-website}}
To make use of the Greengo CSS, follow the instruction on how to {\hyperref[\detokenize{websites/css:include-css}]{\sphinxcrossref{\DUrole{std,std-ref}{Include CSS in a Website}}}}.


\section{CSS}
\label{\detokenize{websites/css:css}}\label{\detokenize{websites/css::doc}}

\subsection{Include CSS in a Website}
\label{\detokenize{websites/css:include-css-in-a-website}}\label{\detokenize{websites/css:include-css}}
To include the Greengo CSS into a website, do as follow:
\begin{itemize}
\item {} 
Clone the \sphinxcode{\sphinxupquote{greengo\_website\_css}} repository.

\item {} 
{\hyperref[\detokenize{websites/css:install-dependencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Install Dependencies}}}}.

\item {} 
{\hyperref[\detokenize{websites/css:compile-sass-to-css}]{\sphinxcrossref{\DUrole{std,std-ref}{Compile SASS to CSS}}}}.

\item {} 
Create a soft link (generally called symlink) to the \sphinxcode{\sphinxupquote{dist/}} folder in your websites static assets.
This can be easily done in graphical user interface or using the following Bash command: \sphinxcode{\sphinxupquote{ln -s /path/to/file /path/to/symlink}}.
The documentation of the website will probably include the specific name and location of the symlink that you should create.

\end{itemize}


\subsection{Install Dependencies}
\label{\detokenize{websites/css:install-dependencies}}\label{\detokenize{websites/css:id1}}
\sphinxcode{\sphinxupquote{yarn install}}

\begin{sphinxadmonition}{caution}{Caution:}
Please use \sphinxstyleemphasis{YARN} and \sphinxstyleemphasis{not NPM} for dependency management.

NPM will also work and will not break anything.
Nevertheless, YARN is faster and better.
\end{sphinxadmonition}


\subsection{Compile SASS to CSS}
\label{\detokenize{websites/css:compile-sass-to-css}}\label{\detokenize{websites/css:id2}}
One-time Compilation: \sphinxcode{\sphinxupquote{yarn css-build}}.

Auto-recompile on change: \sphinxcode{\sphinxupquote{yarn css-watch}}.
An alias for the previous command exists: \sphinxcode{\sphinxupquote{yarn start}}.


\subsection{Getting Started}
\label{\detokenize{websites/css:getting-started}}
If you are writing CSS code for Greengo for the first time, I would recommend having a look at the following:
\begin{itemize}
\item {} 
Briefly: \sphinxhref{https://sass-lang.com/}{SASS}

\item {} 
More in Depth Look: \sphinxhref{https://bulma.io/documentation/}{Bulma}

\end{itemize}


\subsection{Development Process}
\label{\detokenize{websites/css:development-process}}
When developing a CSS framework for a website, create a new SASS file in \sphinxcode{\sphinxupquote{sass/root/}} that has the name of the website you are building.
In this file, import all the required SASS source code from Bulma.

\begin{sphinxadmonition}{warning}{Warning:}
Do no change the Bulma code directly!

As this will prevent upgrading to newer versions of Bulma
Instead, add your styles into the \sphinxcode{\sphinxupquote{style}} folder.
\end{sphinxadmonition}

All files in the \sphinxcode{\sphinxupquote{style}} folder, should start with \sphinxcode{\sphinxupquote{\_}}.
This tells the CSS build pipeline to not build the file which is the desired behavior as files in \sphinxcode{\sphinxupquote{style}} should only be imported into other SASS files.

Please notice that changes made to style in this repository will affect \sphinxtitleref{all} greengo websites.

\begin{sphinxadmonition}{warning}{Warning:}
Do not remove existing CSS code unless you are sure it is used by \sphinxstyleemphasis{no} greengo website, otherwise it will break the websites using the style.
\end{sphinxadmonition}


\subsection{Missing CSS Functionality}
\label{\detokenize{websites/css:missing-css-functionality}}
If Bulma does not contain the CSS feature you are interested in, it is recommended to first look for community-provided snippets targeted for Bulma.
If there are none, then high-quality CSS code can be found in the Bootstrap project (moderately customizable) and the Foundation project (highly-customizable).

Taking CSS code from other CSS projects, will require to change the variable names in the imported code, to make them match the Bulma naming convention.


\subsection{Deployment}
\label{\detokenize{websites/css:deployment}}
The CSS distribution files are automatically built and deployed to Google Cloud Storage when committing on the \sphinxcode{\sphinxupquote{master}} branch or when creating a \sphinxcode{\sphinxupquote{vX.Y.Z}} tag, where \sphinxcode{\sphinxupquote{X}}, \sphinxcode{\sphinxupquote{Y}} and \sphinxcode{\sphinxupquote{Z}} are the major version, the minor version and the fix respectively.
See {\hyperref[\detokenize{software_engineering:semantic-versioning}]{\sphinxcrossref{\DUrole{std,std-ref}{Semantic Versioning}}}} for details on the versioning convention.


\section{Greengo Sales}
\label{\detokenize{websites/greengo_sales:greengo-sales}}\label{\detokenize{websites/greengo_sales::doc}}
A website to sell the Greengo project to states and companies.


\subsection{Goal}
\label{\detokenize{websites/greengo_sales:goal}}
This website‚Äôs target audience are entities that can setup Greengo for cities/countries/privately own roads.


\subsection{CSS}
\label{\detokenize{websites/greengo_sales:css}}
CSS from the \sphinxcode{\sphinxupquote{greengo\_website\_css}} repository should be included by creating a symlink to the distribution folder of the CSS repo.
The symlink path must be \sphinxcode{\sphinxupquote{static/css}}.


\subsection{Development}
\label{\detokenize{websites/greengo_sales:development}}
To start the development server: \sphinxcode{\sphinxupquote{yarn dev}}.
The development server live reloads the page when the content on disk is changed.


\subsection{Deployment}
\label{\detokenize{websites/greengo_sales:deployment}}
Upon committing on the \sphinxcode{\sphinxupquote{master}} branch, the website is automatically built for production (\sphinxcode{\sphinxupquote{yarn export}}) and deployed to Firebase hosting.

\begin{sphinxadmonition}{warning}{Warning:}
The latest version of the greengo CSS will be fetched automatically in this process.

The folder \sphinxcode{\sphinxupquote{static/css/}} that you have locally on your machine is \sphinxstyleemphasis{not} synced by Git, which is the desired behavior.
When deploying the website, the last version of the CSS is automatically downloaded.
\end{sphinxadmonition}


\chapter{Microservices}
\label{\detokenize{microservices:microservices}}\label{\detokenize{microservices::doc}}
Following is the documentation of each microservice in Greengo.


\section{Contract Maker}
\label{\detokenize{microservices/contract_maker/index:contract-maker}}\label{\detokenize{microservices/contract_maker/index::doc}}

\subsection{Input}
\label{\detokenize{microservices/contract_maker/input:input}}\label{\detokenize{microservices/contract_maker/input::doc}}
The contract maker v1 takes as input a trigger and an intersection configuration.


\subsubsection{Trigger}
\label{\detokenize{microservices/contract_maker/input:trigger}}
Triggers are received from the \sphinxcode{\sphinxupquote{contract\_scheduler}} microservice.
A trigger contains:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{intersection\_id}}: the intersection for which to create the contract.

\item {} 
\sphinxcode{\sphinxupquote{contract\_duration\_millis}}: contract duration in milliseconds.

\end{itemize}


\subsubsection{Intersection Configuration}
\label{\detokenize{microservices/contract_maker/input:intersection-configuration}}
The contract maker retrieves intersection configuration from the Map Preprocessing microservice.
For each intersection this includes two pieces of information: phases and connections which are described below.


\paragraph{Phases}
\label{\detokenize{microservices/contract_maker/input:phases}}
A phase is a list of \sphinxcode{\sphinxupquote{duration\_of\_phase}} in seconds and  a \sphinxcode{\sphinxupquote{state\_of\_phase}} where state\_of\_phase is a string of characters in \{r, y, g, G, s, u, o, O\} where the character in the first position corresponds to connection with id 0 (see below), second character corresponds to connection 1 and so on‚Ä¶

For your convenience, we put here the meanings of each character in the sequence \sphinxcode{\sphinxupquote{state\_of\_phase}}, retrieved from Sumo documentation:
\begin{itemize}
\item {} 
r: ‚Äòred light‚Äô for a signal - vehicles must stop.

\item {} 
y: ‚Äòamber (yellow) light‚Äô for a signal - vehicles will start to decelerate if far away from the junction, otherwise they pass.

\item {} 
g: ‚Äògreen light‚Äô for a signal, no priority - vehicles may pass the junction if no vehicle uses a higher priorised foe stream, otherwise they decelerate for letting it pass.
They always decelerate on approach until they are within the configured visibility distance.

\item {} 
G: ‚Äògreen light‚Äô for a signal, priority - vehicles may pass the junction.

\item {} 
s: ‚Äògreen right-turn arrow‚Äô requires stopping - vehicles may pass the junction if no vehicle uses a higher priorised foe stream.
They always stop before passing. This is only generated for junction type traffic\_light\_right\_on\_red.

\item {} 
u: ‚Äòred+yellow light‚Äô for a signal, may be used to indicate upcoming green phase but vehicles may not drive yet (shown as orange in the gui).

\item {} 
o: ‚Äòoff - blinking‚Äô signal is switched off, blinking light indicates vehicles have to yield.

\item {} 
O: ‚Äòoff - no signal‚Äô signal is switched off, vehicles have the right of way.

\end{itemize}


\paragraph{Connections}
\label{\detokenize{microservices/contract_maker/input:connections}}
A connection comprises two pieces of info:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{id\_of\_previous\_SUMO\_junction\_leading\_to\_junction}} as a String.

\item {} 
\sphinxcode{\sphinxupquote{DirectionsAndLinkIndexes}} which is a list of tuples (\sphinxcode{\sphinxupquote{direction}}, \sphinxcode{\sphinxupquote{index\_of\_connection}}) where direction is in enum (‚Äús‚Äù = straight, ‚Äút‚Äù = turn, ‚Äúl‚Äù = left, ‚Äúr‚Äù = right, ‚ÄúL‚Äù = partially left, R = partially right, ‚Äúinvalid‚Äù = no direction), and the index\_of\_connection is the connection id used to identify which character in the \sphinxcode{\sphinxupquote{state\_of\_phase}} corresponds to this connection.

\end{itemize}

In short, aconnection is identified by a previous intersection id and a direction, and has an id to identify its phase.


\subsection{Output}
\label{\detokenize{microservices/contract_maker/output:output}}\label{\detokenize{microservices/contract_maker/output::doc}}
The contract maker produces a contract: traffic light assignment for each lane.
\begin{itemize}
\item {} 
A contract is a list of phases.

\item {} 
A phase has a duration and is a map of each connection in the intersection to a traffic light color.

\item {} 
A connection (or link) with respect to an intersection is a pair (previous incoming intersection, direction).

\item {} 
A direction is one of the following:  enum (‚Äús‚Äù = straight, ‚Äút‚Äù = turn, ‚Äúl‚Äù = left, ‚Äúr‚Äù = right, ‚ÄúL‚Äù = partially left, R = partially right, ‚Äúinvalid‚Äù = no direction).

\end{itemize}


\subsection{Sharding}
\label{\detokenize{microservices/contract_maker/sharding:sharding}}\label{\detokenize{microservices/contract_maker/sharding::doc}}
For the contract maker, the sharding will be done similarly to vehicle localization: per region.


\subsection{Improvement Ideas for Contract Maker v2}
\label{\detokenize{microservices/contract_maker/improvements:improvement-ideas-for-contract-maker-v2}}\label{\detokenize{microservices/contract_maker/improvements::doc}}

\subsubsection{Input}
\label{\detokenize{microservices/contract_maker/improvements:input}}
The next version of the contract maker could take the followings into consideration:
\begin{itemize}
\item {} 
Intersection state (number of vehicle on each approach) once the traffic microservice is developped.

\item {} 
Previously generated contracts for the same intersection to avoid conflicts.

\end{itemize}


\subsubsection{Sharding and scaling}
\label{\detokenize{microservices/contract_maker/improvements:sharding-and-scaling}}
Kubernetes: 1 cluster per region, scale up following number of messages


\section{Contract Scheduler}
\label{\detokenize{microservices/contract_scheduler/index:contract-scheduler}}\label{\detokenize{microservices/contract_scheduler/index::doc}}

\subsection{Introduction}
\label{\detokenize{microservices/contract_scheduler/introduction:introduction}}\label{\detokenize{microservices/contract_scheduler/introduction::doc}}

\subsubsection{Goal}
\label{\detokenize{microservices/contract_scheduler/introduction:goal}}
Handles the scheduling of the contracts.
This includes defining when to create the next contract and how long the next contract should last.

Send PubSub messages shortly before a new contract needs to be created.


\subsubsection{Nomenclature}
\label{\detokenize{microservices/contract_scheduler/introduction:nomenclature}}
The messages on PubSub that should trigger the creation of new contracts are called \sphinxstyleemphasis{triggers}.


\subsubsection{Instance Input}
\label{\detokenize{microservices/contract_scheduler/introduction:instance-input}}
A map (intersection id -\textgreater{} topic name) that should contain the list of all intersections that should be handled by the given instance and the name of the topic on which to send the triggers for each intersection.


\subsubsection{Instance Output}
\label{\detokenize{microservices/contract_scheduler/introduction:instance-output}}
Trigger messages on the appropriate pubsub topic.


\subsubsection{Inputs When Creating a Trigger}
\label{\detokenize{microservices/contract_scheduler/introduction:inputs-when-creating-a-trigger}}
First Implementation: none.

In the future:
\begin{itemize}
\item {} 
Current traffic

\item {} 
Past traffic patterns

\item {} 
Median LTE delay on approaches

\item {} 
Previous contract information

\item {} 
etc.

\end{itemize}


\subsubsection{Sharding}
\label{\detokenize{microservices/contract_scheduler/introduction:sharding}}
Trigger messages needs to be sharded per region because the contract maker is sharded by regions (as it needs to have the intersection configurations in memory).

Intersections are grouped into clusters (a file contains such a mapping), the contract scheduler is sharded based on this mapping.


\subsubsection{Setting GCP credentials}
\label{\detokenize{microservices/contract_scheduler/introduction:setting-gcp-credentials}}
Before running the contract\_scheduler, make sure you:
\begin{itemize}
\item {} 
Clone greengo\_credentials

\item {} 
Set an environment variable GOOGLE\_APPLICATION\_CREDENTIALS pointing to greengo\_credentialsgcloudgreengo-test-aeafd7da1830.json

\end{itemize}


\subsection{Simplifications and Assumptions}
\label{\detokenize{microservices/contract_scheduler/simplification_and_assumptions:simplifications-and-assumptions}}\label{\detokenize{microservices/contract_scheduler/simplification_and_assumptions::doc}}

\subsubsection{First Implementation}
\label{\detokenize{microservices/contract_scheduler/simplification_and_assumptions:first-implementation}}\begin{itemize}
\item {} 
Send triggers based on fixed rate. Delay between triggers should be sum of the duration of all the phases produced by the traffic light preprocessing.

\item {} 
No verification that contract was indeed created; assume that everything happens smoothly at the contract maker level.

\item {} 
No check before starting the service. Assume the instance is the only one running and that no contracts were ever created before.

\end{itemize}


\subsubsection{Needed Improvements}
\label{\detokenize{microservices/contract_scheduler/simplification_and_assumptions:needed-improvements}}
Implement a communication cycle between the scheduler and the maker which would approximately work as follow:
\begin{itemize}
\item {} 
Contract Scheduler sends a trigger that contains a unique trigger id to the Contract maker.

\item {} 
Contract Maker creates a contract then sends an acknowledgement to the Contract Scheduler containing the id and some of the informations in the contract (to alleviate the need to fetch those info from the DB on the scheduler level)

\item {} 
Use the received information to compute when to send the next trigger.

\item {} 
If the scheduler does not receive an acknowledgment in some predefined time, resend a trigger.

\end{itemize}

Each instance will need to take into account the existing contracts upon startup.


\section{Traffic}
\label{\detokenize{microservices/traffic/index:traffic}}\label{\detokenize{microservices/traffic/index::doc}}
\sphinxstylestrong{Goal:} Compute in real time the number of vehicle coming on each approach of an intersection for all intersection.

\sphinxstylestrong{Topics:} Vehicle localization outputs all localization messages on a single topic (no sharding)

The traffic microservice listen to those localization messages and update the database containing the state of each intersection.


\section{Vehicle Localization}
\label{\detokenize{microservices/vehicle_localization/index:vehicle-localization}}\label{\detokenize{microservices/vehicle_localization/index:id1}}\label{\detokenize{microservices/vehicle_localization/index::doc}}

\subsection{Introduction}
\label{\detokenize{microservices/vehicle_localization/introduction:introduction}}\label{\detokenize{microservices/vehicle_localization/introduction::doc}}

\subsubsection{Goal}
\label{\detokenize{microservices/vehicle_localization/introduction:goal}}
The vehicle localization service maps vehicle coordinates to a tuple \sphinxcode{\sphinxupquote{(previous\_junction\_id, next\_junction\_id)}}.


\subsubsection{What It does}
\label{\detokenize{microservices/vehicle_localization/introduction:what-it-does}}
When running, the vehicle localization does the following:
\begin{itemize}
\item {} 
Subscribe to a given list of topics containing vehicle positions.

\item {} 
Receive messages from subscribed topics that contain a sequence of noisy positions from a given vehicle.

\item {} 
Map match (i.e. snap to the map) those coordinates using the Open Source Routing Machine (OSRM, deployed as a docker container along side this service).
This also returns the id of the last node crossed by the vehicle.

\item {} 
If the vehicle is too close to an intersection, compute the matching junction id and return a tuple \sphinxcode{\sphinxupquote{(current junction id, -1)}}

\item {} 
Else, using the map matched coordinates and the last crossed node id, retrieve from the values of the preprocessing the list of possible next node.

\item {} 
Compute the most probable next node by measuring the distance between the vehicle and the segments (last crossed node, next possible node).

\item {} 
Use the last crossed node and the most probable next node to retrieve the current edge id and next junction id from the preprocessing values.

\end{itemize}


\subsubsection{Requirements}
\label{\detokenize{microservices/vehicle_localization/introduction:requirements}}
To properly function, the vehicle localization service has the following main requirements:
\begin{itemize}
\item {} 
An area.
The service will only perform computations for vehicle that are in the given area.

\item {} 
Valid and complete preprocessing data for the area.

\item {} 
Running OSRM server that has at least the data for the area covered by the service.

\end{itemize}


\subsection{Building the Vehicle Localization}
\label{\detokenize{microservices/vehicle_localization/building:building-the-vehicle-localization}}\label{\detokenize{microservices/vehicle_localization/building:building-vehicle-localization}}\label{\detokenize{microservices/vehicle_localization/building::doc}}
This project is managed using Gradle.
To build the project, use \sphinxcode{\sphinxupquote{./gradlew shadowJar}} which will create a self-contained executable JAR in the \sphinxcode{\sphinxupquote{builds/lib/}} folder.

Other build option available include:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{./gradlew clean}} to clean the output folder.

\item {} 
\sphinxcode{\sphinxupquote{./gradlew compileScala}} to compile the Scala code.

\item {} 
\sphinxcode{\sphinxupquote{./gradlew jar}} to create a Jar containing just the compiled code of the micro-service (dependencies are not included).

\item {} 
\sphinxcode{\sphinxupquote{./gradlew lintGradle}} to lint the gradle code.

\end{itemize}

The complete list of available commands can be obtained with \sphinxcode{\sphinxupquote{./gradlew tasks}}.


\subsection{Running}
\label{\detokenize{microservices/vehicle_localization/running:running}}\label{\detokenize{microservices/vehicle_localization/running::doc}}
This page describes how to execute the vehicle localization microservice.


\subsubsection{Required Google Cloud Credentials}
\label{\detokenize{microservices/vehicle_localization/running:required-google-cloud-credentials}}
Because the vehicle localization connects to Google PubSub, it requires Google Cloud credentials.
The path to a credential file should be made available to the program by defining an environment variable:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{GOOGLE\PYGZus{}APPLICATION\PYGZus{}CREDENTIALS}\PYG{o}{=}\PYGZlt{}path\PYGZgt{}
\end{sphinxVerbatim}

Where \sphinxcode{\sphinxupquote{\textless{}path\textgreater{}}} is the path of a JSON file containing credentials to access Google Cloud.
Such a file can be created from the Google Cloud Console in the IAM panel.

If you have the \sphinxcode{\sphinxupquote{gcloud}} command-line installed on your system, you do need to setup credentials.
Make sure however that the default project is configured correctly, namely that it is set to \sphinxcode{\sphinxupquote{greengo-test}}.


\subsubsection{Running Locally}
\label{\detokenize{microservices/vehicle_localization/running:running-locally}}
Sometimes, it might be wanted to run the \sphinxcode{\sphinxupquote{vehicle\_localization}} module (e.g. for testing/debugging purposes).

Following are the instructions to follow to run the module locally.


\paragraph{Just the Vehicle Localization}
\label{\detokenize{microservices/vehicle_localization/running:just-the-vehicle-localization}}
To run this microservice you will need a working Java Runtime Environment (abreviated JRE).

Build the microservice as explained in {\hyperref[\detokenize{microservices/vehicle_localization/building:building-vehicle-localization}]{\sphinxcrossref{\DUrole{std,std-ref}{Building the Vehicle Localization}}}}.

Then run \sphinxcode{\sphinxupquote{./gradlew runShadow}}.
Alternatively, you can use the following commands:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{./gradlew run}} to run the project as a JVM application.

\item {} 
\sphinxcode{\sphinxupquote{java -jar ./build/libs/greengo\_vehicle\_localization-*.jar}} to run the shadowJar using the JVM directly.

\end{itemize}


\paragraph{The OSRM Server}
\label{\detokenize{microservices/vehicle_localization/running:the-osrm-server}}
The Open Source Routing Machine comes package as a Docker container.
However, before you can launch the OSRM server, you will need to prepare the data it requires to work.

There are two options to obtain those data:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download raw Open Street Map data and preprocess them.
Hereafter are given the commands to execute to preprocess the map of Switzerland.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget http://download.geofabrik.de/europe/switzerland\PYGZhy{}latest.osm.pbf
sudo docker run \PYGZhy{}t \PYGZhy{}v \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PWD}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{:/data}\PYG{l+s+s2}{\PYGZdq{}} osrm/osrm\PYGZhy{}backend osrm\PYGZhy{}extract \PYGZhy{}p /opt/car.lua /data/berlin\PYGZhy{}latest.osm.pbf
sudo docker run \PYGZhy{}t \PYGZhy{}v \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PWD}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{:/data}\PYG{l+s+s2}{\PYGZdq{}} osrm/osrm\PYGZhy{}backend osrm\PYGZhy{}partition /data/switzerland\PYGZhy{}latest.osrm
sudo docker run \PYGZhy{}t \PYGZhy{}v \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PWD}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{:/data}\PYG{l+s+s2}{\PYGZdq{}} osrm/osrm\PYGZhy{}backend osrm\PYGZhy{}customize /data/switzerland\PYGZhy{}latest.osrm
\end{sphinxVerbatim}

\item {} 
Download already preprocessed data from Greengo using the \sphinxcode{\sphinxupquote{gcloud}} command-line.

\end{enumerate}

To launch the OSRM server run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo docker run \PYGZhy{}t \PYGZhy{}i \PYGZhy{}p \PYG{l+m}{5000}:5000 \PYGZhy{}v \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PWD}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{:/data}\PYG{l+s+s2}{\PYGZdq{}} osrm/osrm\PYGZhy{}backend osrm\PYGZhy{}routed \PYGZhy{}\PYGZhy{}algorithm mld /data/switzerland\PYGZhy{}latest.osrm
\end{sphinxVerbatim}


\subsection{Parametrization}
\label{\detokenize{microservices/vehicle_localization/parametrization:parametrization}}\label{\detokenize{microservices/vehicle_localization/parametrization::doc}}
The following parameters are available to customize the behavior of the vehicle localization service.


\subsubsection{Algorithm}
\label{\detokenize{microservices/vehicle_localization/parametrization:algorithm}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{tooCloseToIntersectionToPredictNextIntersectionDistance}}:
The minimum distance between a vehicle and a node connected to multiple way required for the vehicle localization to make a prediction.

\end{itemize}


\subsubsection{Area}
\label{\detokenize{microservices/vehicle_localization/parametrization:area}}
???


\subsection{Vocabulary}
\label{\detokenize{microservices/vehicle_localization/vocabulary:vocabulary}}\label{\detokenize{microservices/vehicle_localization/vocabulary::doc}}
The following section explains the meaning of various words used in the context of this service.


\subsubsection{Human Vocabulary}
\label{\detokenize{microservices/vehicle_localization/vocabulary:human-vocabulary}}\begin{itemize}
\item {} 
Road: A vaguely defined entity, sometimes meaning a segment of asphalt going from one intersection to another, sometimes meaning a segment of asphalt that has the same given name.

\item {} 
Intersection: Generally equivalent to a SUMO junction; the crossing of multiple roads or the splitting of one.

\end{itemize}


\subsubsection{OSM Vocabulary}
\label{\detokenize{microservices/vehicle_localization/vocabulary:osm-vocabulary}}\begin{itemize}
\item {} 
Node: A point on the map defined by tuple of coordinate (latitude, longitude).
A node might be assigned additional values and metadata.

\item {} 
Way: A double linked list of nodes, can span multiple intersections.

\end{itemize}


\subsubsection{Sumo Vocabulary}
\label{\detokenize{microservices/vehicle_localization/vocabulary:sumo-vocabulary}}\begin{itemize}
\item {} 
Junction: An intersection of multiple edges that form a single ‚Äúintersection‚Äù as human tend to understand it.
They are associated with a polygon and an id.
Please note that OSM does \sphinxstyleemphasis{not} have the concept of intersection, it is only aware of nodes shared by multiple ways, but an ‚Äúintersection‚Äù can be composed of multiple such nodes.

\item {} 
Edge: a road segment linking a junction to another, undirected, composed of several lanes.

\item {} 
Lane: Always part of an edge, directed, represent real life lane.

\end{itemize}


\subsubsection{Vehicle Localization Vocabulary}
\label{\detokenize{microservices/vehicle_localization/vocabulary:vehicle-localization-vocabulary}}\begin{itemize}
\item {} 
Segment: A Segment is defined as the segment of road between two OSM node belonging to the same Way.

\end{itemize}


\subsection{Algorithms}
\label{\detokenize{microservices/vehicle_localization/algorithms:algorithms}}\label{\detokenize{microservices/vehicle_localization/algorithms::doc}}

\subsubsection{Vehicle Localization}
\label{\detokenize{microservices/vehicle_localization/algorithms:vehicle-localization}}
This is the algorithm used to perform the main task of this micro-service, namely computing a \sphinxcode{\sphinxupquote{prev\_junction}} and an \sphinxcode{\sphinxupquote{next\_junction}} given the last few positions emitted by the vehicle.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Send the list of noisy GPS coords to OSMR, receive \sphinxcode{\sphinxupquote{snapped\_coordinates}} and \sphinxcode{\sphinxupquote{crossed\_node}}. Define \sphinxcode{\sphinxupquote{last\_crossed\_node}} as the last node crossed.

\item {} 
Use \sphinxcode{\sphinxupquote{last\_crossed\_node}} to compute \sphinxcode{\sphinxupquote{next\_node}}:
\begin{itemize}
\item {} 
Retrieve all OSM ways connected to \sphinxcode{\sphinxupquote{last\_crossed\_node}}.

\item {} 
If there is only one way (or two ways and the two start or end at \sphinxcode{\sphinxupquote{last\_crossed\_node}}), find nodes before and after \sphinxcode{\sphinxupquote{last\_crossed\_node}}, compute to which segment the vehicle is closer, set \sphinxcode{\sphinxupquote{next\_node}} to the node of the closest way segment.

\item {} 
If multiple ways were returned (\sphinxcode{\sphinxupquote{last\_crossed\_node}} is an intersection):
\begin{enumerate}
\def\theenumii{\arabic{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
If the vehicle is too close to the intersection to make a sound decision, set \sphinxcode{\sphinxupquote{next\_node}} to \sphinxcode{\sphinxupquote{last\_crossed\_node}}.

\item {} 
Otherwise, retrieve list of nodes associated to each way, find node before and after \sphinxcode{\sphinxupquote{last\_crossed\_node}} in each way.

\item {} 
Using \sphinxcode{\sphinxupquote{snapped\_coordinates}}, measure how close to the line between the node and the last crossed node the vehicle is.

\item {} 
Keep the closest segment, set \sphinxcode{\sphinxupquote{next\_node}} to the corresponding next node.

\end{enumerate}

\end{itemize}

\item {} 
Look \sphinxcode{\sphinxupquote{(last\_crossed\_node, next\_node)}} up in the mapping provided by the preprocessing, return the obtained \sphinxcode{\sphinxupquote{(prev\_junction, next\_junction)}}.

\end{enumerate}

This solution requires the following mappings to be available:
\begin{itemize}
\item {} 
A working OSMR server (OSMR is open source)

\item {} 
\sphinxcode{\sphinxupquote{(node\_id) -\textgreater{} (node)}} mapping (preprocessing on OSM file)

\item {} 
\sphinxcode{\sphinxupquote{(way\_id) -\textgreater{} (way)}} mapping, need to return both node\_ids and node\_coords (preprocessing on OSM file)

\item {} 
\sphinxcode{\sphinxupquote{(last\_crossed\_node\_id, next\_node\_id) -\textgreater{} (prev\_junction\_id, next\_junction\_id)}} (heavy-lifting preprocessing on Sumo network file)

\end{itemize}

Further, looking up \sphinxcode{\sphinxupquote{(last\_crossed\_node\_id, last\_crossed\_node\_id)}} should always return \sphinxcode{\sphinxupquote{(junction\_id, -1)}} where \sphinxcode{\sphinxupquote{junction\_id}} is the id of the junction containing \sphinxcode{\sphinxupquote{last\_crossed\_node}} given that \sphinxcode{\sphinxupquote{last\_crossed\_node}} is part of some junction.


\subsubsection{Distances Computations}
\label{\detokenize{microservices/vehicle_localization/algorithms:distances-computations}}
Greengo only requires measuring short distances, therefore for simpicity and execution speed it was decided to measure distance using the \(L_2\) norm.

GPS use the \sphinxhref{https://en.wikipedia.org/wiki/World\_Geodetic\_System}{WGS84} Coordinate Reference System.
We consider WGS84 coordinates to be spherical coordinates with a fixed Earth radius for simplification.

To measure distance at the surface of the Earth, ‚Äúspherical coordinates‚Äù are converted to cartesian coordinates using the \sphinxhref{https://en.wikipedia.org/wiki/List\_of\_common\_coordinate\_transformations\#To\_spherical\_coordinates}{standard transformation}.
Then distances are measured using the \(L_2\) norm (the euclidean norm), thus ignoring the curvature of the Earth which is fine for short distances.

We remark that the localization service only needs to measure short distances.


\subsection{Testing}
\label{\detokenize{microservices/vehicle_localization/testing:testing}}\label{\detokenize{microservices/vehicle_localization/testing::doc}}
There are two types of tests available for this project:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Unit tests in the \sphinxcode{\sphinxupquote{src/test/}} source set.

\item {} 
Integration tests in the \sphinxcode{\sphinxupquote{src/it/}} source set.

\end{enumerate}

Commands to execute the tests:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{./gradlew check}} to execute all tests.

\item {} 
\sphinxcode{\sphinxupquote{./gradlew test}} to execute just the unit tests.

\item {} 
\sphinxcode{\sphinxupquote{./gradlew integrationTest}} to execute just the integration tests.

\end{itemize}


\section{Map Preprocessing}
\label{\detokenize{microservices/map_preprocessing/index:map-preprocessing}}\label{\detokenize{microservices/map_preprocessing/index::doc}}

\subsection{Introduction}
\label{\detokenize{microservices/map_preprocessing/introduction:introduction}}\label{\detokenize{microservices/map_preprocessing/introduction::doc}}

\subsubsection{Goal}
\label{\detokenize{microservices/map_preprocessing/introduction:goal}}
This script preprocesses map regions in preparation for multiple Greengo services: localisation, contract maker, traffic ‚Ä¶


\subsubsection{Running}
\label{\detokenize{microservices/map_preprocessing/introduction:running}}
Input:
\begin{itemize}
\item {} 
Coordinate bounding box of region where Greengo will be deployed (min\_lat, max\_lat, min\_lon, max\_lon)

\end{itemize}

\sphinxstylestrong{Example:} Run the command for the Vaud region:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 localization\PYGZus{}preprocessing.py \PYG{l+m}{5}.8057 \PYG{l+m}{46}.1258 \PYG{l+m}{7}.2859 \PYG{l+m}{46}.8475
\end{sphinxVerbatim}

When running, the map preprocessing script does the following:
\begin{itemize}
\item {} 
Divides inputed region into cells of size 0.2 latitude degrees and 0.2 longitude degrees.

\item {} 
For each map cell:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The OSM map is downloaded.

\item {} 
The OSM map data is filtered to contain only relevant data.

\item {} 
The OSM map is parsed.

\item {} 
The OSM map is converted to SUMO format.

\item {} 
The SUMO XML file is parsed.

\item {} 
The dictionary (next\_osm\_node\_id, next\_osm\_node\_id) -\textgreater{} (previous\_sumo\_junction\_id, next\_sumo\_junction\_id) is created

\item {} 
Traffic lights are added to all junctions in the SUMO network. They are then parsed and saved to JSON file.

\item {} 
OSRM preprocessing script is executed.

\item {} 
All preprocessing data is uploaded to GCP cloud storage. The GCP bucket name is ‚Äòpreprocessed\_maps\_json‚Äô and each region‚Äôs data is in this bucket in a directory named after the region‚Äôs id. For example, region ‚Äò488-1138‚Äô data can be found at ‚Äòpreprocessed\_maps\_json/488-1138/‚Äô.

\item {} 
Local files are removed

\end{enumerate}

\end{itemize}


\subsubsection{Requirements}
\label{\detokenize{microservices/map_preprocessing/introduction:requirements}}
To properly function, the map preprocessing script has the following main requirements:
\begin{itemize}
\item {} 
SUMO installed

\item {} 
Internet connection to connect to overpass API

\item {} 
Docker installed

\end{itemize}


\subsection{Map Preprocessing}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:map-preprocessing}}\label{\detokenize{microservices/map_preprocessing/map_preprocessing::doc}}
The goal of the map preprocessing is to create the following dictionary: \sphinxcode{\sphinxupquote{(next\_osm\_node\_id, next\_osm\_node\_id) -\textgreater{} (previous\_sumo\_junction\_id, next\_sumo\_junction\_id)}}.
This mapping maps a previous OSM node and a next OSM node to the previous SUMO junction on this way and the next SUMO junction on this way.


\subsubsection{The Problem}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:the-problem}}
OpenStreetMaps does not provide intersections.
OSM provides \sphinxstyleemphasis{ways} that represent road segments and are made up of an ordered list of \sphinxstyleemphasis{nodes}.
At an intersection, a single node can belong to multiple ways.
However, a \sphinxstyleemphasis{node} belonging to multiple \sphinxstyleemphasis{ways} does necessarily mean that the node can be considered as an intersection.
For example below we have 4 of these nodes but only a single intersection.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osm_4_nodes}.png}
\caption{Example OSM intersection described by 4 nodes.}\label{\detokenize{microservices/map_preprocessing/map_preprocessing:id1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osm_way_map}.png}
\caption{Example OSM way and the list of ordered nodes it contains.}\label{\detokenize{microservices/map_preprocessing/map_preprocessing:id2}}\end{figure}


\subsubsection{Download OSM map}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:download-osm-map}}
The OSM map data is downloaded from \sphinxurl{https://overpass-api.de/} API.
It offers an API to download any map region (of reasonable size, i.e: not entire continents).
API requests are sometimes refused. In this case, the map download is tried again every 5 min until it is successful.


\subsubsection{Filter Map}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:filter-map}}
The OSM map data is filtered to get rid of irrelevant information (footpaths, constructions, etc‚Ä¶) right after being downloaded.
For this, the tool \sphinxurl{https://wiki.openstreetmap.org/wiki/Osmfilter} is used.


\subsubsection{Convert to SUMO format}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:convert-to-sumo-format}}
SUMO does provide intersections/junctions.
We use NETCONVERT (\sphinxurl{https://sumo.dlr.de/docs/NETCONVERT.html}) to convert the osm map data to SUMO type.
This tools contains many options which may have to be tweaked depending on the road infrastructure of a given map region (to deal with roundabouts or unreliable OSM data for example).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sumo_junction}.png}
\caption{Example SUMO junction. In this case, the SUMO junction is a cluster of OSM nodes.}\label{\detokenize{microservices/map_preprocessing/map_preprocessing:id3}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sumo_xml}.png}
\caption{Example SUMO xml format to describe a junction.}\label{\detokenize{microservices/map_preprocessing/map_preprocessing:id4}}\end{figure}


\subsubsection{Preprocess}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:preprocess}}
Both the SUMO XML file and the OSM data are combined to create the following dictionaries:
\begin{itemize}
\item {} 
OSM nodes contains \sphinxcode{\sphinxupquote{\{"node\_id": str, "lat": str, "lon": str, "connected\_ways": list{[}str{]}\}}}

\item {} 
OSM Ways contains \sphinxcode{\sphinxupquote{\{"way\_id": str, "node\_ids": list{[}str{]}\}}}

\item {} 
OSM node pair to SUMO junction pair contains \sphinxcode{\sphinxupquote{\{"from\_node\_id": str, "to\_node\_id" : str, "prev\_junction\_id": str, "next\_junction\_id": str, "osm\_node\_of\_intersection\_entry": str\}}}, \sphinxcode{\sphinxupquote{osm\_node\_of\_intersection\_entry}} is the OSM node the road leading to the intersection ends at.

\end{itemize}


\subsubsection{Cloud Storage}
\label{\detokenize{microservices/map_preprocessing/map_preprocessing:cloud-storage}}
The nodes dictionary is then stored on GCP in JSON format in a file called \sphinxcode{\sphinxupquote{OSM\_nodes}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}262654407\PYGZdq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}262654407\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lat\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}48.1499816\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lon\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}6.0076407\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}connected\PYGZus{}ways\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}
         \PYG{l+s+s2}{\PYGZdq{}299843535\PYGZdq{}}
      \PYG{p}{]}
   \PYG{p}{\PYGZcb{}}\PYG{p}{,}
   \PYG{n+nt}{\PYGZdq{}262654426\PYGZdq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}262654426\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lat\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}48.1580923\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lon\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}6.0084214\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}connected\PYGZus{}ways\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}
         \PYG{l+s+s2}{\PYGZdq{}635446992\PYGZdq{}}
      \PYG{p}{]}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

You can view the above example OSM nodes in the following OSM viewer:  \sphinxurl{https://www.openstreetmap.org/node/262654426}

The ways dictionary is then stored on GCP in JSON format in a file called \sphinxcode{\sphinxupquote{OSM\_ways}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}24259607\PYGZdq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}way\PYGZus{}id\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}24259607\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}node\PYGZus{}ids\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}
         \PYG{l+s+s2}{\PYGZdq{}262655677\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}1917565155\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}1917565157\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}1917565159\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}1917565161\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}262654800\PYGZdq{}}
      \PYG{p}{]}
   \PYG{p}{\PYGZcb{}}\PYG{p}{,}
   \PYG{n+nt}{\PYGZdq{}26001452\PYGZdq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}way\PYGZus{}id\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}26001452\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}node\PYGZus{}ids\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}
         \PYG{l+s+s2}{\PYGZdq{}283669071\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}3199617322\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}3199617324\PYGZdq{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}3199617326\PYGZdq{}}
      \PYG{p}{]}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

You can view the above example OSM ways in the following OSM viewer:  \sphinxurl{https://www.openstreetmap.org/way/26001452}

The OSM to SUMO dictionary is then stored on GCP in JSON format in a file called \sphinxcode{\sphinxupquote{osm\_node\_pair\_to\_SUMO\_junction\_pair}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}junctions\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}
      \PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}from\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}to\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}prev\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}next\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}from\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}to\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}prev\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}next\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}from\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}to\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}prev\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}30229084\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}next\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002387255\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}from\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1088793816\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}to\PYGZus{}node\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002388918\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}prev\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1088793816\PYGZdq{}}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}next\PYGZus{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1002388918\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{l+s+s2}{\PYGZdq{}...\PYGZdq{}}
   \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Each object in the \sphinxcode{\sphinxupquote{junction}} identifies a directed road segment between 2 junctions.


\subsection{Traffic Light Preprocessing}
\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing:traffic-light-preprocessing}}\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing::doc}}

\subsubsection{Computing Traffic Light Phases}
\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing:computing-traffic-light-phases}}
We use SUMO (\sphinxurl{https://sumo.dlr.de/docs/Simulation/Traffic\_Lights.html}) to compute safe and efficient traffic light phases for each junction in a map region.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sumo_tl}.png}
\caption{Example SUMO traffic light scheme at an intersection.}\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing:id1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sumo_tl_xml}.png}
\caption{Example SUMO xml format for describing traffic light phases.}\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing:id2}}\end{figure}


\subsubsection{Storage}
\label{\detokenize{microservices/map_preprocessing/traffic_light_preprocessing:storage}}
The traffic light phases are stored on GCP in JSON files called \sphinxcode{\sphinxupquote{traffic\_light\_data}} that have the following structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}junction\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}phases\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
         \PYG{p}{\PYGZob{}}
            \PYG{n+nt}{\PYGZdq{}duration\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}10\PYGZdq{}}\PYG{p}{,}
            \PYG{n+nt}{\PYGZdq{}state\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}}
         \PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}...\PYGZdq{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}connections\PYGZdq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}id\PYGZus{}of\PYGZus{}previous\PYGZus{}SUMO\PYGZus{}junction\PYGZus{}leading\PYGZus{}to\PYGZus{}junction\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}direction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}s\PYGZdq{}}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}linkIndex\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}0\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}\PYG{p}{,}
            \PYG{l+s+s2}{\PYGZdq{}...\PYGZdq{}}
         \PYG{p}{]}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}...\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}\PYG{p}{,}
   \PYG{n+nt}{\PYGZdq{}...\PYGZdq{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}1038547759\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}phases\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
         \PYG{p}{\PYGZob{}}
            \PYG{n+nt}{\PYGZdq{}duration\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}42\PYGZdq{}}\PYG{p}{,}
            \PYG{n+nt}{\PYGZdq{}state\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}GGrr\PYGZdq{}}
         \PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{p}{\PYGZob{}}
            \PYG{n+nt}{\PYGZdq{}duration\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}3\PYGZdq{}}\PYG{p}{,}
            \PYG{n+nt}{\PYGZdq{}state\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}yyrr\PYGZdq{}}
         \PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{p}{\PYGZob{}}
            \PYG{n+nt}{\PYGZdq{}duration\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}42\PYGZdq{}}\PYG{p}{,}
            \PYG{n+nt}{\PYGZdq{}state\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}rrGG\PYGZdq{}}
         \PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{p}{\PYGZob{}}
            \PYG{n+nt}{\PYGZdq{}duration\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}3\PYGZdq{}}\PYG{p}{,}
            \PYG{n+nt}{\PYGZdq{}state\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}rryy\PYGZdq{}}
         \PYG{p}{\PYGZcb{}}
      \PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}connections\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
         \PYG{n+nt}{\PYGZdq{}300560165\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}direction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}s\PYGZdq{}}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}linkIndex\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}2\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}\PYG{p}{,}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}direction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}l\PYGZdq{}}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}linkIndex\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}3\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
         \PYG{p}{]}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}1038547757\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}direction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}r\PYGZdq{}}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}linkIndex\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}0\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}\PYG{p}{,}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}direction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}s\PYGZdq{}}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}linkIndex\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}1\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
         \PYG{p}{]}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{OSRM Preprocessing}
\label{\detokenize{microservices/map_preprocessing/osrm_preprocessing:osrm-preprocessing}}\label{\detokenize{microservices/map_preprocessing/osrm_preprocessing::doc}}
The OSRM map-matching algorithm requires map data that takes a few minutes to preprocess.
To save time when launching a {\hyperref[\detokenize{microservices/vehicle_localization/index:vehicle-localization}]{\sphinxcrossref{\DUrole{std,std-ref}{Vehicle Localization}}}} microservice instance, we compute the required files in advance and store them on GCP.

Docker image and documentation: \sphinxurl{https://hub.docker.com/r/osrm/osrm-backend/}.

All files created by OSRM docker container‚Äôs preprocessing computation are stored on GCP in a subdirectory inside the map region‚Äôs folder under the name ‚Äòosrm\_data‚Äô.


\subsection{Ongoing issues and concerns}
\label{\detokenize{microservices/map_preprocessing/ongoing_issues:ongoing-issues-and-concerns}}\label{\detokenize{microservices/map_preprocessing/ongoing_issues::doc}}\begin{itemize}
\item {} 
Detect and deal with roundabouts.
They do not need to be equipped with virtual traffic lights.
Need to be accurately detected and dealt with.

\item {} 
Phantom junctions.
Inaccurate OSM maps create many \sphinxstyleemphasis{phantom} junctions which need to be detected and removed.

\item {} 
Bifurcations and similar junctions.

\item {} 
Detect when Overpass download fails and try again.

\item {} 
Add manual verification step.

\item {} 
Road loops cause issues.
We identify directed road segment between 2 junctions using ordered pair (previous\_SUMO\_junction, next\_SUMO\_junction).
Sometimes two road segments exist with same pair.

\end{itemize}


\section{Driver App}
\label{\detokenize{microservices/driver_app/index:driver-app}}\label{\detokenize{microservices/driver_app/index::doc}}

\subsection{Screens}
\label{\detokenize{microservices/driver_app/screens:screens}}\label{\detokenize{microservices/driver_app/screens::doc}}

\subsubsection{Authentication Screen}
\label{\detokenize{microservices/driver_app/screens:authentication-screen}}
The authentication screen contains the following elements:


\paragraph{Form}
\label{\detokenize{microservices/driver_app/screens:form}}
The form always includes:
\begin{itemize}
\item {} 
VTL‚Äôs Logo

\item {} 
Email input field

\item {} 
A primary button
\begin{itemize}
\item {} 
Toggles between ‚ÄòLogin‚Äô, ‚ÄòCreate account‚Äô or ‚ÄòReset Password‚Äô depending on the current form showing

\item {} 
Pressing Login using valid credentials will redirect the user to the map and traffic light screen

\item {} 
Pressing Login using invalid credentials generates an error messages

\item {} 
Pressing Create account after entering some credentials will create an account with those credentials

\item {} 
Pressing Reset Password with an existing address email will show a confirmation popup and the user will receive an email to reset his password. The user is then redirected to the login screen.

\end{itemize}

\item {} 
A secondary button
\begin{itemize}
\item {} 
Toggles between ‚ÄòCreate an account‚Äô and  ‚ÄòHave an account? Sign in‚Äô

\item {} 
Pressing ‚ÄòCreate an account‚Äô will make the form switch to sign up mode instead of login mode

\item {} 
Pressing ‚ÄòHave an account? Sign in‚Äô will make the form switch to login mode instead of sign up mode

\end{itemize}

\item {} 
A third button
\begin{itemize}
\item {} 
This button displays ‚ÄòForgot your password?‚Äô is always visible, except when the Reset Password form is showing.

\item {} 
Pressing Forgot your password will make the form switch to reset password mode

\end{itemize}

\end{itemize}

The form can also include:
\begin{itemize}
\item {} 
Password input field: Always present, except when the form is in the Reset Password mode

\item {} 
Error messages when there is an error parsing the user‚Äôs entry in one of the input fields

\end{itemize}


\paragraph{Circular Progress}
\label{\detokenize{microservices/driver_app/screens:circular-progress}}
Shows a circular progress indicator when screen is loading


\paragraph{Password Reinitialized Popup}
\label{\detokenize{microservices/driver_app/screens:password-reinitialized-popup}}
When password successfully reinitialized, a popup appears confirming the password reinitializtion and inviting the user to check his emails to reinitialized his password.


\subsubsection{Map and Traffic Light Screen}
\label{\detokenize{microservices/driver_app/screens:map-and-traffic-light-screen}}
‚Äã
The Map and Traffic Light Screen contains the following elements:


\paragraph{Traffic Light Widget}
\label{\detokenize{microservices/driver_app/screens:traffic-light-widget}}
The traffic light card shows current road name as well as next intersection traffic light status. The traffic light has two display modes depending on the next intersection:


\subparagraph{Different Lights Displayed}
\label{\detokenize{microservices/driver_app/screens:different-lights-displayed}}\begin{itemize}
\item {} 
If the intersection has traffic light information about at least one direction (left, right or straight), the widget displays 3 lights with a directional arrow in them. The lights are displayed in this order: left, straight and right. All 3 lights can have a different status (color) and if the next intersection does not have all 3 directions, the remaining lights are hidden.

\item {} 
If the intersection does not have specific direction information, only one traffic light with no arrow in it is displayed at the center of the widget.

\end{itemize}


\subparagraph{Meaning of the Colors}
\label{\detokenize{microservices/driver_app/screens:meaning-of-the-colors}}
The meanings of the colors are given under {\hyperref[\detokenize{taxonomy_serialization:traffic-light-value}]{\sphinxcrossref{\DUrole{std,std-ref}{Traffic Light Value}}}}.


\paragraph{A Map}
\label{\detokenize{microservices/driver_app/screens:a-map}}
Built using google maps package for flutter.
Shows user location and automatically center and rotate the map on the user location and heading.


\paragraph{Buttons}
\label{\detokenize{microservices/driver_app/screens:buttons}}

\subparagraph{Zoom Buttons}
\label{\detokenize{microservices/driver_app/screens:zoom-buttons}}
On the left of the screen, two zoom buttons allow the user to zoom in or zoom out on the map.


\subparagraph{Enable/disable Auto-Center Button}
\label{\detokenize{microservices/driver_app/screens:enable-disable-auto-center-button}}
On the top left, a two states button permits to disable the auto centering and rotating to allow the user to scroll and zoom with gestures on the map to see the surrounding area.
Pressing the button a second time will enable auto centering and rotating again and reset the view to the zoom level it was before.


\subparagraph{Logout Floating Button}
\label{\detokenize{microservices/driver_app/screens:logout-floating-button}}
On the bottom right, a floating button logs the user out when pressed.


\subsection{Services}
\label{\detokenize{microservices/driver_app/services:services}}\label{\detokenize{microservices/driver_app/services::doc}}

\subsubsection{Firebase}
\label{\detokenize{microservices/driver_app/services:firebase}}
Firebase Authentication provides backend services and UI libraries to authenticate users of the app.
We use the Flutter plugin \sphinxcode{\sphinxupquote{firebase\_auth}} in this app.
All firebase authentication functionalities are defined in the file \sphinxcode{\sphinxupquote{authentication.dart}} located in \sphinxcode{\sphinxupquote{services/firebase/}}, these include:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{signIn}}: A method used to log in using an email and a password.

\item {} 
\sphinxcode{\sphinxupquote{signUp}}: A method used to register a new user.

\item {} 
\sphinxcode{\sphinxupquote{getCurrentUser}}: Returns the currently signed in Firebase user.

\item {} 
\sphinxcode{\sphinxupquote{sendEmailVerification}}: Initiates email verification for the user.

\item {} 
\sphinxcode{\sphinxupquote{signOut}}: Signs out the current user.

\item {} 
\sphinxcode{\sphinxupquote{isEmailVerified}}: True if the users email is verified.

\item {} 
\sphinxcode{\sphinxupquote{resetPassword}}: Send email to the given email address, which must correspond to an existing user of the app.

\end{itemize}


\subsubsection{Google Pub/Sub}
\label{\detokenize{microservices/driver_app/services:google-pub-sub}}
The driver app communicates with other microservices through Google pub/sub.
We use the Flutter package \sphinxcode{\sphinxupquote{gcloud}} in this app.
Methods to create a pubsub instance and publish a byte messages are defined in the file \sphinxcode{\sphinxupquote{pub\_sub\_sender.dart}} located in \sphinxcode{\sphinxupquote{services/gcloud/}}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{initWithTopic}}: Creates a pubsub instance running on the app and sends a test message.

\item {} 
\sphinxcode{\sphinxupquote{publishByteMessage}}: Takes a byte message and a topic name as arguments and publishes the byte message on the given topic.

\end{itemize}


\subsubsection{Pusher}
\label{\detokenize{microservices/driver_app/services:pusher}}
All incoming messages to the app are received through Pusher.
Pusher is a hosted service that makes it super-easy to add real-time data and functionality to mobile applications.
We use the Flutter package \sphinxcode{\sphinxupquote{pusher\_websocket\_flutter}} in this app.
Tests have been carried out where correct reception of the messages sent to the app through Pusher was verified.
All pusher related functionalities are in defined in \sphinxcode{\sphinxupquote{pusher\_receiver.dart}} located in \sphinxcode{\sphinxupquote{services/pusher/}}.
These include:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{init}}: Initialize and connect to the pusher project defined by the fields \sphinxcode{\sphinxupquote{\_appKey}} and \sphinxcode{\sphinxupquote{\_pusherCluster}}.

\item {} 
\sphinxcode{\sphinxupquote{subscribeToChannelAndBindEvent}}: Connect to channel and bind the channel to an event with the a given callback.

\item {} 
\sphinxcode{\sphinxupquote{unbindEventAndUnsubscribeFromChannel}}: Unbind event from channel then unsubscribe from channel.

\item {} 
\sphinxcode{\sphinxupquote{disconnect}}: Disconnect from the pusher project.

\end{itemize}


\subsection{Algorithm for Sending Vehicles‚Äô Coordinates}
\label{\detokenize{microservices/driver_app/algorithm:algorithm-for-sending-vehicles-coordinates}}\label{\detokenize{microservices/driver_app/algorithm::doc}}
This is the algorithm used to perform one of the main tasks of this micro-service, namely sending waypoints of the vehicle on its last 100 meters (approximately) to Google pub/sub for other micro-services (like Vehicle Localization) to be able to use them.

Goal: send filtered waypoints to Google pub/sub given a bunch of noisy and probably redundant coordinates from phones GPS
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Wait until user has given the app access to localization and GPS is enabled.

\item {} 
Filter coordinates using the following criterion: The smallest allowed distance between two consecutive points is \sphinxcode{\sphinxupquote{minDelta}} which is set to 5 meters.

\item {} 
Remove points from te linked list if the two folowing conditions are met.

\end{enumerate}
\begin{itemize}
\item {} 
The sum of all distances between the points kept is more than \sphinxcode{\sphinxupquote{historyLength}} which is set to 100 meters.

\item {} 
The number of points in the linked list is larger than minPoints which is set to 5.

\end{itemize}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{3}
\item {} 
Serialize the obtained linked list of filtered messages using protocol buffer.

\item {} 
Send filtred serialized messages to Google pub/sub every \sphinxcode{\sphinxupquote{timeout}}, which is set to 5 seconds.

\end{enumerate}


\section{Contract Dispatcher}
\label{\detokenize{microservices/contract_dispatcher/index:contract-dispatcher}}\label{\detokenize{microservices/contract_dispatcher/index::doc}}

\subsection{Introduction}
\label{\detokenize{microservices/contract_dispatcher/introduction:introduction}}\label{\detokenize{microservices/contract_dispatcher/introduction::doc}}
The Contract Dispatcher service dispatches the contracts created by Greengo to the pusher channel corresponding to the intersection to which the contract applies.


\subsection{Implementation}
\label{\detokenize{microservices/contract_dispatcher/implementation:implementation}}\label{\detokenize{microservices/contract_dispatcher/implementation::doc}}

\subsubsection{Technologies}
\label{\detokenize{microservices/contract_dispatcher/implementation:technologies}}
This service is built using the Scala language.
It uses the following libraries:
\begin{itemize}
\item {} 
Google pubsub API for Java

\item {} 
Pusher server API for Java

\item {} 
Google protocol buffers (ScalaPB)

\end{itemize}


\subsubsection{Implementation Details}
\label{\detokenize{microservices/contract_dispatcher/implementation:implementation-details}}
The service pulls messages from the pubsub subscription \sphinxcode{\sphinxupquote{contract-dispatcher}} on the topic \sphinxcode{\sphinxupquote{contract}} and publishes them to the pusher channel \sphinxcode{\sphinxupquote{"intersection-" + intersection\_id}}.

The driver app should ideally be subscribed to all of its surrounding intersection‚Äôs pusher channels to have immediate access to new contracts as it passes an intersection.


\section{Localization Dispatcher}
\label{\detokenize{microservices/localization_dispatcher/index:localization-dispatcher}}\label{\detokenize{microservices/localization_dispatcher/index::doc}}

\subsection{Introduction}
\label{\detokenize{microservices/localization_dispatcher/introduction:introduction}}\label{\detokenize{microservices/localization_dispatcher/introduction::doc}}
The Localization Dispatcher service dispatches the vehicle localization information produced by Greengo to the relevant user app.
It filters those information by user id so as to distribute localization information to the correct user.


\subsection{Implementation}
\label{\detokenize{microservices/localization_dispatcher/implementation:implementation}}\label{\detokenize{microservices/localization_dispatcher/implementation::doc}}

\subsubsection{Technologies}
\label{\detokenize{microservices/localization_dispatcher/implementation:technologies}}
This service is built using the Scala language.
It uses the following libraries:
\begin{itemize}
\item {} 
Google pubsub API for Java

\item {} 
Pusher server API for Java

\item {} 
Google protocol buffers

\end{itemize}


\subsubsection{Implementation Details}
\label{\detokenize{microservices/localization_dispatcher/implementation:implementation-details}}
The service pulls messages from the pubsub subscription \sphinxcode{\sphinxupquote{localization-dispatcher}} on the topic \sphinxcode{\sphinxupquote{vehicle-localizations}} and publishes them on the pusher channel \sphinxcode{\sphinxupquote{"vehicle-" + vehicleId}}.

The driver app should be subscribed to its pusher channel to receive information on what its next intersection is so it can subscribe to the correct contracts channels.



\renewcommand{\indexname}{Index}
\printindex
\end{document}